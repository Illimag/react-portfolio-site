"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const minimist = require("minimist");
const path = require("path");
const typescript_1 = require("typescript");
const createTransformer_1 = require("./createTransformer");
class Compiler {
    constructor(args) {
        this.diagnosticsHost = this.createDiagnosticsHost();
        this.config = this.createConfig(args.tsconfigPath, args.commandLine);
        this.compilerHost = typescript_1.createCompilerHost(this.config.options);
        this.printer = typescript_1.createPrinter();
    }
    createDiagnosticsHost() {
        const diagnosticsHost = {
            getCurrentDirectory: typescript_1.sys.getCurrentDirectory,
            getCanonicalFileName: path.normalize,
            getNewLine() {
                return typescript_1.sys.newLine;
            },
        };
        return diagnosticsHost;
    }
    createConfigFileHost() {
        const diagnosticsHost = this.diagnosticsHost;
        const configFileHost = {
            onUnRecoverableConfigFileDiagnostic(diagnostic) {
                console.error(typescript_1.formatDiagnostic(diagnostic, diagnosticsHost));
            },
            useCaseSensitiveFileNames: false,
            readDirectory: typescript_1.sys.readDirectory,
            fileExists: typescript_1.sys.fileExists,
            readFile: typescript_1.sys.readFile,
            getCurrentDirectory: typescript_1.sys.getCurrentDirectory,
        };
        return configFileHost;
    }
    showDiagnostics(diagnostics) {
        throw typescript_1.formatDiagnosticsWithColorAndContext(diagnostics, this.diagnosticsHost);
    }
    createConfig(tsconfigPath = path.join(__dirname, 'tsconfig.json'), commandLine) {
        const configFileHost = this.createConfigFileHost();
        const config = typescript_1.getParsedCommandLineOfConfigFile(tsconfigPath, typescript_1.parseCommandLine(commandLine).options, configFileHost);
        if (!config) {
            throw 'Error parsing config file';
        }
        const diagnostics = typescript_1.getConfigFileParsingDiagnostics(config);
        if (diagnostics.length) {
            this.showDiagnostics(diagnostics);
        }
        return config;
    }
    createProgram(compilerHost, oldProgram) {
        const { fileNames, options } = this.config;
        const program = typescript_1.createProgram(fileNames, options, compilerHost, oldProgram);
        const preEmitDiagnostics = typescript_1.getPreEmitDiagnostics(program);
        if (preEmitDiagnostics.length) {
            this.showDiagnostics(preEmitDiagnostics);
        }
        return program;
    }
    getTransformed(program) {
        const sourceFiles = program.getSourceFiles();
        const sourseTsxFiles = sourceFiles.filter(({ fileName }) => fileName.match(/\.tsx$/));
        const { transformed } = typescript_1.transform(sourseTsxFiles, [createTransformer_1.default()]);
        return transformed.reduce((dict, file) => {
            dict[file.fileName] = file;
            return dict;
        }, {});
    }
    wrapCompilerHost(host, transformed) {
        return Object.assign({}, host, { getSourceFile: (fileName, version) => {
                if (transformed[fileName]) {
                    return typescript_1.createSourceFile(fileName, this.printer.printFile(transformed[fileName]), version);
                }
                else {
                    return host.getSourceFile(fileName, version);
                }
            } });
    }
    run() {
        const program = this.createProgram(this.compilerHost);
        const transformed = this.getTransformed(program);
        const wrappedHost = this.wrapCompilerHost(this.compilerHost, transformed);
        const finalProgram = this.createProgram(wrappedHost, program);
        const emitResult = finalProgram.emit();
        if (emitResult.diagnostics.length) {
            this.showDiagnostics(emitResult.diagnostics);
        }
        const exitCode = emitResult.emitSkipped ? 1 : 0;
        process.exit(exitCode);
    }
}
const parsedCommandLine = minimist(process.argv);
const commandLinePath = parsedCommandLine.config || parsedCommandLine.c;
const tsconfigPath = commandLinePath ? path.join(process.cwd(), commandLinePath) : undefined;
const compiler = new Compiler({
    commandLine: process.argv,
    tsconfigPath: tsconfigPath,
});
compiler.run();

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("typescript");
/**
 * Gets import names if node is an import declaration.
 * Checks for the patterns:
 * import { var1, var2 as var3 } from 'somewhere';
 * import * as all from 'all';
 * import defaultVariable from 'somelib';
 * @param node
 */
function getImports(node) {
    const imports = {};
    if (typescript_1.isImportDeclaration(node) && node.importClause) {
        const { importClause } = node;
        if (importClause.name) {
            imports[importClause.name.text] = importClause.name;
        }
        if (importClause.namedBindings) {
            const { namedBindings } = importClause;
            if (typescript_1.isNamespaceImport(namedBindings) && namedBindings.name.text !== 'from') {
                imports[namedBindings.name.text] = namedBindings.name;
            }
            else if (typescript_1.isNamedImports(namedBindings)) {
                namedBindings.elements.forEach(importSpecifier => {
                    imports[importSpecifier.name.text] = importSpecifier.name;
                });
            }
        }
    }
    return imports;
}
/**
 * Gets function parameters
 * @param node
 */
function getFunctionParameters(node) {
    const parameters = {};
    if (node && (typescript_1.isFunctionDeclaration(node) || typescript_1.isFunctionExpression(node) || typescript_1.isArrowFunction(node))) {
        node.parameters.forEach(parameter => {
            if (typescript_1.isIdentifier(parameter.name)) {
                parameters[parameter.name.text] = parameter.name;
            }
        });
    }
    return parameters;
}
/**
 * Gets all node's variable names
 * @param node
 */
function getVariables(node) {
    const variables = {};
    if (typescript_1.isVariableStatement(node)) {
        node.declarationList.declarations.forEach(({ name }) => {
            if (typescript_1.isIdentifier(name)) {
                variables[name.text] = name;
            }
            else if (typescript_1.isObjectBindingPattern(name)) {
                name.elements.forEach(({ name }) => {
                    if (typescript_1.isIdentifier(name)) {
                        variables[name.text] = name;
                    }
                });
            }
        });
    }
    return variables;
}
/**
 * If function declaration then reutrns function name
 * @param node
 */
function getFunctionName(node) {
    if (typescript_1.isFunctionDeclaration(node) && node.name) {
        return node.name;
    }
    return undefined;
}
/**
 * If class decalration then return class name
 * @param node
 */
function getClassName(node) {
    if (typescript_1.isClassDeclaration(node) && node.name) {
        return node.name;
    }
    return undefined;
}
/**
 * Checks for the pattern:
 * class SomeComponentName extends React.* {
 *   ...
 * }
 * @param node
 */
function isReactClass(node) {
    if (typescript_1.isClassDeclaration(node) &&
        node.heritageClauses &&
        node.heritageClauses[0].types &&
        node.heritageClauses[0].types[0].expression &&
        typescript_1.isPropertyAccessExpression(node.heritageClauses[0].types[0].expression) &&
        typescript_1.isIdentifier(node.heritageClauses[0].types[0].expression.expression) &&
        node.heritageClauses[0].types[0].expression.expression.text === 'React') {
        return true;
    }
    return false;
}
/**
 * Checks for the patterns:
 * const SomeComponent: React.* = () => ....
 * let SomeComponent2: React.* = function() {}
 * @param node
 */
function isReactFunctionDeclaration(node) {
    if (typescript_1.isVariableStatement(node) &&
        node.declarationList &&
        node.declarationList.declarations &&
        node.declarationList.declarations.length === 1) {
        const declaration = node.declarationList.declarations[0];
        const { type, initializer } = declaration;
        if (type &&
            initializer &&
            (typescript_1.isArrowFunction(initializer) || typescript_1.isFunctionExpression(initializer)) &&
            typescript_1.isTypeReferenceNode(type) &&
            typescript_1.isQualifiedName(type.typeName) &&
            typescript_1.isIdentifier(type.typeName.left) &&
            type.typeName.left.text === 'React') {
            return true;
        }
    }
    return false;
}
/**
 * Gets all variable, function, class declaration names
 * which are in the same or higher scope of the node.
 * @param node
 */
function getScope(node) {
    let dict = {};
    if (!node.parent) {
        return dict;
    }
    node.parent.forEachChild(cbNode => {
        if (cbNode === node) {
            return;
        }
        const functionName = getFunctionName(cbNode);
        if (functionName) {
            dict[functionName.text] = functionName;
        }
        const className = getClassName(cbNode);
        if (className) {
            dict[className.text] = className;
        }
        dict = Object.assign({}, dict, getImports(cbNode), getVariables(cbNode), getFunctionParameters(cbNode.parent));
    });
    dict = Object.assign({}, dict, getScope(node.parent));
    return dict;
}
/**
 * Creates an inner object from available jsx tags list:
 *
 * {
 *     get A() { return A as typeof A; },
 *     get B() { return B as typeof B; },
 *     get C() { return C as typeof C; },
 * }
 *
 * @param jsxTags
 */
function createInner(jsxTags) {
    return typescript_1.createObjectLiteral(jsxTags.map(tag => typescript_1.createGetAccessor(undefined, undefined, tag.text, [], undefined, typescript_1.createBlock([typescript_1.createReturn(typescript_1.createAsExpression(tag, typescript_1.createTypeQueryNode(tag)))]))), true);
}
/**
 * Identifies if node is react class or variable statement.
 * @param node
 */
function isReactStatement(node) {
    if (typescript_1.isClassDeclaration(node)) {
        return isReactClass(node);
    }
    else if (typescript_1.isVariableStatement(node)) {
        return isReactFunctionDeclaration(node);
    }
    return false;
}
/**
 * Visits each node and finds JSX tags. Then assigns them to Map() where keys are references to
 * React class/variable declarations which contain these JSX tags. Assigns only those tags which lay
 * in the same or higher scope as React class/variable declaration.
 * @param node
 * @param reactStatement
 * @param scopeVariables
 * @param result
 */
function buildJsxMap(node, reactStatement, scopeVariables, result = new Map()) {
    node.forEachChild(child => {
        if (!child.parent) {
            child.parent = node;
        }
        if (scopeVariables && reactStatement && (typescript_1.isJsxOpeningElement(child) || typescript_1.isJsxSelfClosingElement(child))) {
            const tagName = child.tagName;
            if (typescript_1.isIdentifier(tagName)) {
                const { text } = tagName;
                if (scopeVariables[text]) {
                    result.set(reactStatement, Object.assign({}, result.get(reactStatement), { [text]: scopeVariables[text] }));
                }
            }
        }
        else if (isReactStatement(child)) {
            buildJsxMap(child, child, getScope(child), result);
        }
        else {
            buildJsxMap(child, reactStatement, scopeVariables, result);
        }
    });
    return result;
}
/**
 * Adds static inner object to React class.
 *
 * class Component extends React.Component {
 *   render() {
 *       return <InnerComponent />
 *   }
 * }
 *
 * ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
 *
 * class Component extends React.Component {
 *   render() {
 *       return <InnerComponent />
 *   }
 *
 *   static inner = {
 *       get Component(){ return Component; }
 *   }
 * }
 * @param statement
 * @param type
 */
function updateReactClassStatement(statement, inner) {
    const property = typescript_1.createProperty(undefined, [typescript_1.createToken(typescript_1.SyntaxKind.StaticKeyword)], 'inner', undefined, undefined, inner);
    const members = typescript_1.createNodeArray([...statement.members, property]);
    return typescript_1.updateClassDeclaration(statement, statement.decorators, statement.modifiers, statement.name, statement.typeParameters, statement.heritageClauses, members);
}
/**
 * Updates React variable decalration
 *
 * const Component: React.SFC<{}> = () => <InnerComponent />
 *
 * ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
 *
 * const Component = Object.assign(() => <InnerComponent />) as React.SFC<{}>, { inner: { get Component(){ return Component; } } } }
 * @param statement
 * @param type
 */
function updateReactVariableStatement(statement, inner) {
    const { declarationList, modifiers } = statement;
    const variableDeclaration = declarationList.declarations[0];
    if ((declarationList.declarations && declarationList.declarations.length !== 1) ||
        !variableDeclaration.initializer ||
        !variableDeclaration.type) {
        return statement;
    }
    return typescript_1.updateVariableStatement(statement, modifiers, typescript_1.updateVariableDeclarationList(declarationList, [
        typescript_1.updateVariableDeclaration(variableDeclaration, variableDeclaration.name, undefined, typescript_1.createCall(typescript_1.createPropertyAccess(typescript_1.createIdentifier('Object'), typescript_1.createIdentifier('assign')), undefined, [
            typescript_1.createAsExpression(typescript_1.createParen(variableDeclaration.initializer), variableDeclaration.type),
            typescript_1.createObjectLiteral([typescript_1.createPropertyAssignment('inner', inner)]),
        ])),
    ]));
}
function createTransformer() {
    const transformer = context => {
        return sourceFile => {
            const jsxMap = buildJsxMap(sourceFile);
            const visitor = node => {
                node.forEachChild(n => {
                    if (!n.parent) {
                        n.parent = node;
                    }
                });
                let updatedNode = node;
                if (typescript_1.isBlock(node) || typescript_1.isDefaultClause(node) || typescript_1.isModuleBlock(node) || typescript_1.isSourceFile(node)) {
                    const statements = node.statements.map(statement => {
                        if (jsxMap.has(statement)) {
                            const jsxTags = Object.keys(jsxMap.get(statement)).map(key => jsxMap.get(statement)[key]);
                            if (jsxTags.length) {
                                const inner = createInner(jsxTags);
                                if (isReactClass(statement)) {
                                    return updateReactClassStatement(statement, inner);
                                }
                                else if (isReactFunctionDeclaration(statement)) {
                                    return updateReactVariableStatement(statement, inner);
                                }
                            }
                        }
                        return statement;
                    });
                    if (typescript_1.isBlock(node)) {
                        updatedNode = typescript_1.updateBlock(node, statements);
                    }
                    else if (typescript_1.isDefaultClause(node)) {
                        updatedNode = typescript_1.updateDefaultClause(node, statements);
                    }
                    else if (typescript_1.isModuleBlock(node)) {
                        updatedNode = typescript_1.updateModuleBlock(node, statements);
                    }
                    else if (typescript_1.isSourceFile(node)) {
                        updatedNode = typescript_1.updateSourceFileNode(node, statements);
                    }
                }
                return typescript_1.visitEachChild(updatedNode, visitor, context);
            };
            return typescript_1.visitNode(sourceFile, visitor);
        };
    };
    return transformer;
}
exports.createTransformer = createTransformer;
exports.default = createTransformer;

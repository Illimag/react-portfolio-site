var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import * as React from 'react';
import styled, { themed, css } from '../../utils/styled';
import { remCalc } from '../../utils/remCalc';
import { Table } from '../Table';
import { defaultCellRenderer } from '../Table/TableShared.part';
import { Icon } from '../Icon';
import { AccordionTableRow } from '../AccordionTableRow';
import { normalizeIndex, toggleIndex, hasIndex } from './helpers/indexHelper';
import { distance } from '../../distance';
import { getFontStyle } from '../../textStyles';
const animationDuration = '0.3s';
const animationFunction = 'cubic-bezier(0, 0, 0.25, 1)';
const StyledTable = styled(Table) `
  th,
  td {
    padding-right: ${distance.medium};
    padding-left: ${distance.medium};
  }
`;
const StyledTableRowCollapse = styled.tr(themed(({ theme, active }) => css `
      border: ${active ? `1px solid ${theme.ui5}` : 'none'};
      ${!active ? 'display: none;' : ''}
    `));
const StyledCollapseAnimator = styled('div') `
  transition: all ${animationDuration} ${animationFunction};
  max-height: ${({ active }) => (active ? '10000px' : '0')};
  opacity: ${({ active }) => (active ? '1' : '0')};
`;
const GroupTableCell = styled.td `
  ${getFontStyle({ weight: 'bold' })}

  padding-left: 0.5em !important;
`;
const StyledDetailsContainer = styled.td `
  /*
    AccordionTable is a Table abstraction.
    Table has default paddings for it's cells.
    Expanded AccordionTable row is a container and should not have any paddings.
  */
  padding: 0 !important;
`;
const StyledIconInt = Object.assign(((_a) => {
    var { isRotated: _0 } = _a, props = __rest(_a, ["isRotated"]);
    return React.createElement(Icon, Object.assign({}, props));
}), { inner: {
        get Icon() { return Icon; }
    } });
const StyledIcon = styled(StyledIconInt) `
  display: block;
  font-size: ${remCalc('18px')};
  height: 18px;
  width: 18px;
  transition: transform ${animationDuration} ${animationFunction};
  transform: ${({ isRotated }) => `rotate(${isRotated ? 90 : 0}deg)`};
`;
function defaultGroupRenderer(e) {
    return (React.createElement(React.Fragment, null,
        e.group ? e.group.toString() : e.group,
        " (",
        e.items.length,
        ")"));
}
export class AccordionTableBasic extends React.Component {
    constructor(props) {
        super(props);
        this.getGroupByValue = (rowData) => {
            const { groupBy, noValueGroupLabel } = this.props;
            if (groupBy) {
                const rowValue = rowData[groupBy];
                if (rowValue || rowValue === 0) {
                    if (Array.isArray(rowValue) && rowValue.length === 0) {
                        return noValueGroupLabel;
                    }
                    else {
                        return rowValue;
                    }
                }
                else {
                    return noValueGroupLabel;
                }
            }
            return undefined;
        };
        this.rowRenderer = ({ cells, index, data, key, state }) => {
            const { detailsRenderer, rowRenderer, theme, arrowToggle } = this.props;
            const { selectedIndex, expandedGroups } = this.state;
            const { groupedRows = [] } = state;
            const active = hasIndex(selectedIndex, index);
            const count = React.Children.count(cells);
            const col = this.getGroupByValue(data);
            const open = !(col || col === 0) || AccordionTableBasic.arrayIncludes(col, expandedGroups);
            const renderData = { cells, index, data, active, key, state };
            const isNewGroup = (col || col === 0) && !AccordionTableBasic.arrayIncludes(col, groupedRows);
            if (isNewGroup) {
                state.groupedRows = [...groupedRows, col];
            }
            return (React.createElement(React.Fragment, { key: key },
                isNewGroup && this.groupRenderer(col, count, open),
                open && (React.createElement(React.Fragment, null,
                    (rowRenderer && rowRenderer(renderData)) || (React.createElement(AccordionTableRow, { active: active, clickable: !arrowToggle, onClick: () => this.handleClick(index, data), theme: theme }, cells)),
                    React.createElement(StyledTableRowCollapse, { active: active },
                        React.createElement(StyledDetailsContainer, { colSpan: count },
                            React.createElement(StyledCollapseAnimator, { active: active }, active && detailsRenderer && detailsRenderer({ index, data }))))))));
        };
        this.cellRenderer = (e) => {
            const { row, data } = e;
            if (e.column === 0) {
                return (React.createElement(StyledIcon, { isRotated: hasIndex(this.state.selectedIndex, row), name: "KeyboardArrowRight", onClick: () => data && this.handleClick(row, data) }));
            }
            const { cellRenderer } = this.props;
            return typeof cellRenderer === 'function' ? cellRenderer(e) : defaultCellRenderer(e);
        };
        const controlledDetails = props.selectedIndex !== undefined;
        const controlledGroups = Array.isArray(props.expandedGroups);
        this.state = {
            selectedIndex: normalizeIndex(props.selectedIndex),
            controlledIndex: controlledDetails,
            controlledGroups: controlledGroups,
            expandedGroups: controlledGroups ? props.expandedGroups || [] : [],
        };
    }
    static getDerivedStateFromProps(props, state) {
        const { selectedIndex, expandedGroups } = props;
        const newIndex = state.controlledIndex && selectedIndex !== undefined;
        const newGroups = state.controlledGroups && expandedGroups !== undefined;
        if (newIndex || newGroups) {
            return Object.assign({}, state, { selectedIndex: newIndex ? normalizeIndex(selectedIndex) : state.selectedIndex, expandedGroups: newGroups ? expandedGroups : state.expandedGroups });
        }
        return state;
    }
    getGroupItems(data, groupBy, group) {
        const { noValueGroupLabel } = this.props;
        if (groupBy) {
            if (group === noValueGroupLabel) {
                return data.filter(m => {
                    const value = m[groupBy];
                    // the number '0' shouldn't be in the no-value-group.
                    if (typeof value === 'number' && value === 0) {
                        return false;
                    }
                    else {
                        // empty arrays should be in the no-value-group
                        return !value || (Array.isArray(value) && value.length === 0);
                    }
                });
            }
            else {
                return data.filter(m => {
                    const value = m[groupBy];
                    if (value === group) {
                        return true;
                    }
                    else {
                        // special handling for arrays is needed because '===' doesn't work for arrays
                        if (Array.isArray(value) && Array.isArray(group)) {
                            return value.toString() === group.toString();
                        }
                        else {
                            return false;
                        }
                    }
                });
            }
        }
        return [];
    }
    handleClick(target, data) {
        const { onChange, multiple } = this.props;
        const { controlledIndex, selectedIndex } = this.state;
        const nextIndexes = toggleIndex(selectedIndex, target, multiple);
        if (typeof onChange === 'function') {
            onChange({
                selectedIndex: multiple ? nextIndexes : nextIndexes[0] !== undefined ? nextIndexes[0] : -1,
                previousIndex: multiple ? selectedIndex : selectedIndex[0] !== undefined ? selectedIndex[0] : -1,
                data,
            });
        }
        if (!controlledIndex) {
            this.setState({
                selectedIndex: nextIndexes,
            });
        }
    }
    toggleGroup(group) {
        const { data, onToggleGroup, groupBy } = this.props;
        const { expandedGroups, controlledGroups } = this.state;
        if (typeof onToggleGroup === 'function') {
            onToggleGroup({
                group,
                type: 'expand',
                items: this.getGroupItems(data, groupBy, group),
            });
        }
        if (!controlledGroups) {
            if (expandedGroups.indexOf(group) !== -1) {
                this.setState({
                    expandedGroups: expandedGroups.filter(m => m !== group),
                });
            }
            else {
                this.setState({
                    expandedGroups: [...expandedGroups, group],
                });
            }
        }
    }
    groupRenderer(group, count, expanded) {
        const { theme, groupRenderer = defaultGroupRenderer, data, groupBy } = this.props;
        const items = this.getGroupItems(data, groupBy, group);
        return (React.createElement(React.Fragment, null,
            React.createElement(AccordionTableRow, { clickable: true, onClick: () => this.toggleGroup(group), theme: theme },
                React.createElement(GroupTableCell, null,
                    React.createElement(StyledIcon, { isRotated: expanded, name: "KeyboardArrowRight" })),
                React.createElement(GroupTableCell, { colSpan: count - 1 }, groupRenderer({ expanded, group, items }))),
            React.createElement(StyledTableRowCollapse, null)));
    }
    /**
     * helper method to check if an element is included in an array.
     * This method has special handling for arrays of arrays. In this case normal strict equality checking (===)
     * wouldn't work.
     */
    static arrayIncludes(element, arr) {
        return ((Array.isArray(element) ? JSON.stringify(arr).indexOf(JSON.stringify(element)) : arr.indexOf(element)) !== -1);
    }
    getColumns() {
        const { data, columns, indexed } = this.props;
        if (columns || (data && data.length)) {
            const cols = {
                '': {
                    header: '',
                    width: remCalc('50px'),
                    sortable: false,
                },
            };
            if (indexed) {
                cols['#'] = {
                    header: '#',
                    sortable: false,
                };
            }
            const keys = Object.keys(columns || data[0]);
            return keys.reduce((acc, key) => {
                acc[key] = columns ? columns[key] : key;
                return acc;
            }, cols);
        }
        return {};
    }
    render() {
        const _a = this.props, { detailsRenderer: _0, columns: _1, indexed: _2, groupRenderer: _3, expandedGroups: _4, onToggleGroup: _5, openLabel: _6, closeLabel: _7, multiple: _8 } = _a, props = __rest(_a, ["detailsRenderer", "columns", "indexed", "groupRenderer", "expandedGroups", "onToggleGroup", "openLabel", "closeLabel", "multiple"]);
        return (React.createElement(StyledTable, Object.assign({}, props, { mode: "table", columns: this.getColumns(), rowRenderer: this.rowRenderer, cellRenderer: this.cellRenderer })));
    }
}
AccordionTableBasic.defaultProps = {
    multiple: false,
    noValueGroupLabel: '—',
};
AccordionTableBasic.inner = {
    get AccordionTableRow() { return AccordionTableRow; },
    get GroupTableCell() { return GroupTableCell; },
    get StyledIcon() { return StyledIcon; },
    get StyledTableRowCollapse() { return StyledTableRowCollapse; },
    get StyledDetailsContainer() { return StyledDetailsContainer; },
    get StyledCollapseAnimator() { return StyledCollapseAnimator; },
    get StyledTable() { return StyledTable; }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWNjb3JkaW9uVGFibGVCYXNpYy5wYXJ0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQWNjb3JkaW9uVGFibGUvQWNjb3JkaW9uVGFibGVCYXNpYy5wYXJ0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxPQUFPLEtBQUssS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMvQixPQUFPLE1BQU0sRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN6RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDOUMsT0FBTyxFQUFFLEtBQUssRUFBaUIsTUFBTSxVQUFVLENBQUM7QUFDaEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDaEUsT0FBTyxFQUFFLElBQUksRUFBYSxNQUFNLFNBQVMsQ0FBQztBQUMxQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBYWhELE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDO0FBQ2pDLE1BQU0saUJBQWlCLEdBQUcsNkJBQTZCLENBQUM7QUFDeEQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7cUJBR2IsUUFBUSxDQUFDLE1BQU07b0JBQ2hCLFFBQVEsQ0FBQyxNQUFNOztDQUVsQyxDQUFDO0FBQ0YsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLENBQUMsRUFBRSxDQUEwQixNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUs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LENBQUM7SUFDakYsSUFBSSxjQUFjLEtBQUssT0FBTyxjQUF1QyxDQUFDLENBQUMsQ0FBQztJQUN4RSxJQUFJLFVBQVUsS0FBSyxPQUFPLFVBQStCLENBQUMsQ0FBQyxDQUFDO0lBQzVELElBQUksc0JBQXNCLEtBQUssT0FBTyxzQkFBdUQsQ0FBQyxDQUFDLENBQUM7SUFDaEcsSUFBSSxzQkFBc0IsS0FBSyxPQUFPLHNCQUF1RCxDQUFDLENBQUMsQ0FBQztJQUNoRyxJQUFJLHNCQUFzQixLQUFLLE9BQU8sc0JBQXVELENBQUMsQ0FBQyxDQUFDO0lBQ2hHLElBQUksV0FBVyxLQUFLLE9BQU8sV0FBaUMsQ0FBQyxDQUFDLENBQUM7Q0FDbEUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzdHlsZWQsIHsgdGhlbWVkLCBjc3MgfSBmcm9tICcuLi8uLi91dGlscy9zdHlsZWQnO1xuaW1wb3J0IHsgcmVtQ2FsYyB9IGZyb20gJy4uLy4uL3V0aWxzL3JlbUNhbGMnO1xuaW1wb3J0IHsgVGFibGUsIFRhYmxlUm93RXZlbnQgfSBmcm9tICcuLi9UYWJsZSc7XG5pbXBvcnQgeyBkZWZhdWx0Q2VsbFJlbmRlcmVyIH0gZnJvbSAnLi4vVGFibGUvVGFibGVTaGFyZWQucGFydCc7XG5pbXBvcnQgeyBJY29uLCBJY29uUHJvcHMgfSBmcm9tICcuLi9JY29uJztcbmltcG9ydCB7IEFjY29yZGlvblRhYmxlUm93IH0gZnJvbSAnLi4vQWNjb3JkaW9uVGFibGVSb3cnO1xuaW1wb3J0IHsgQWNjb3JkaW9uVGFibGVQcm9wcywgQWNjb3JkaW9uR3JvdXBSZW5kZXJFdmVudCB9IGZyb20gJy4vQWNjb3JkaW9uVGFibGUudHlwZXMucGFydCc7XG5pbXBvcnQgeyBub3JtYWxpemVJbmRleCwgdG9nZ2xlSW5kZXgsIGhhc0luZGV4IH0gZnJvbSAnLi9oZWxwZXJzL2luZGV4SGVscGVyJztcbmltcG9ydCB7IGRpc3RhbmNlIH0gZnJvbSAnLi4vLi4vZGlzdGFuY2UnO1xuaW1wb3J0IHsgVGFibGVDZWxsUmVuZGVyRXZlbnQgfSBmcm9tICcuLi9UYWJsZS9UYWJsZS50eXBlcy5wYXJ0JztcbmltcG9ydCB7IGdldEZvbnRTdHlsZSB9IGZyb20gJy4uLy4uL3RleHRTdHlsZXMnO1xuZXhwb3J0IGludGVyZmFjZSBBY2NvcmRpb25UYWJsZUJhc2ljU3RhdGUge1xuICAgIHNlbGVjdGVkSW5kZXg6IEFycmF5PG51bWJlcj47XG4gICAgZXhwYW5kZWRHcm91cHM6IEFycmF5PGFueT47XG4gICAgY29udHJvbGxlZEluZGV4OiBib29sZWFuO1xuICAgIGNvbnRyb2xsZWRHcm91cHM6IGJvb2xlYW47XG59XG5pbnRlcmZhY2UgQWNjb3JkaW9uVGFibGVJdGVtUHJvcHMge1xuICAgIGFjdGl2ZT86IGJvb2xlYW47XG59XG5pbnRlcmZhY2UgU3R5bGVkQXJyb3dQcm9wcyBleHRlbmRzIEljb25Qcm9wcyB7XG4gICAgaXNSb3RhdGVkOiBib29sZWFuO1xufVxuY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSAnMC4zcyc7XG5jb25zdCBhbmltYXRpb25GdW5jdGlvbiA9ICdjdWJpYy1iZXppZXIoMCwgMCwgMC4yNSwgMSknO1xuY29uc3QgU3R5bGVkVGFibGUgPSBzdHlsZWQoVGFibGUpIGBcbiAgdGgsXG4gIHRkIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAke2Rpc3RhbmNlLm1lZGl1bX07XG4gICAgcGFkZGluZy1sZWZ0OiAke2Rpc3RhbmNlLm1lZGl1bX07XG4gIH1cbmA7XG5jb25zdCBTdHlsZWRUYWJsZVJvd0NvbGxhcHNlID0gc3R5bGVkLnRyPEFjY29yZGlvblRhYmxlSXRlbVByb3BzPih0aGVtZWQoKHsgdGhlbWUsIGFjdGl2ZSB9KSA9PiBjc3MgYFxuICAgICAgYm9yZGVyOiAke2FjdGl2ZSA/IGAxcHggc29saWQgJHt0aGVtZS51aTV9YCA6ICdub25lJ307XG4gICAgICAkeyFhY3RpdmUgPyAnZGlzcGxheTogbm9uZTsnIDogJyd9XG4gICAgYCkpO1xuY29uc3QgU3R5bGVkQ29sbGFwc2VBbmltYXRvciA9IHN0eWxlZCgnZGl2Jyk8QWNjb3JkaW9uVGFibGVJdGVtUHJvcHM+IGBcbiAgdHJhbnNpdGlvbjogYWxsICR7YW5pbWF0aW9uRHVyYXRpb259ICR7YW5pbWF0aW9uRnVuY3Rpb259O1xuICBtYXgtaGVpZ2h0OiAkeyh7IGFjdGl2ZSB9KSA9PiAoYWN0aXZlID8gJzEwMDAwcHgnIDogJzAnKX07XG4gIG9wYWNpdHk6ICR7KHsgYWN0aXZlIH0pID0+IChhY3RpdmUgPyAnMScgOiAnMCcpfTtcbmA7XG5jb25zdCBHcm91cFRhYmxlQ2VsbCA9IHN0eWxlZC50ZCBgXG4gICR7Z2V0Rm9udFN0eWxlKHsgd2VpZ2h0OiAnYm9sZCcgfSl9XG5cbiAgcGFkZGluZy1sZWZ0OiAwLjVlbSAhaW1wb3J0YW50O1xuYDtcbmNvbnN0IFN0eWxlZERldGFpbHNDb250YWluZXIgPSBzdHlsZWQudGQgYFxuICAvKlxuICAgIEFjY29yZGlvblRhYmxlIGlzIGEgVGFibGUgYWJzdHJhY3Rpb24uXG4gICAgVGFibGUgaGFzIGRlZmF1bHQgcGFkZGluZ3MgZm9yIGl0J3MgY2VsbHMuXG4gICAgRXhwYW5kZWQgQWNjb3JkaW9uVGFibGUgcm93IGlzIGEgY29udGFpbmVyIGFuZCBzaG91bGQgbm90IGhhdmUgYW55IHBhZGRpbmdzLlxuICAqL1xuICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XG5gO1xuY29uc3QgU3R5bGVkSWNvbkludCA9IE9iamVjdC5hc3NpZ24oKCgoeyBpc1JvdGF0ZWQ6IF8wLCAuLi5wcm9wcyB9KSA9PiA8SWNvbiB7Li4ucHJvcHN9Lz4pIGFzIFJlYWN0LlNGQzxTdHlsZWRBcnJvd1Byb3BzPiksIHsgaW5uZXI6IHtcbiAgICAgICAgZ2V0IEljb24oKSB7IHJldHVybiBJY29uIGFzIHR5cGVvZiBJY29uOyB9XG4gICAgfSB9KTtcbmNvbnN0IFN0eWxlZEljb24gPSBzdHlsZWQoU3R5bGVkSWNvbkludCk8U3R5bGVkQXJyb3dQcm9wcz4gYFxuICBkaXNwbGF5OiBibG9jaztcbiAgZm9udC1zaXplOiAke3JlbUNhbGMoJzE4cHgnKX07XG4gIGhlaWdodDogMThweDtcbiAgd2lkdGg6IDE4cHg7XG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAke2FuaW1hdGlvbkR1cmF0aW9ufSAke2FuaW1hdGlvbkZ1bmN0aW9ufTtcbiAgdHJhbnNmb3JtOiAkeyh7IGlzUm90YXRlZCB9KSA9PiBgcm90YXRlKCR7aXNSb3RhdGVkID8gOTAgOiAwfWRlZylgfTtcbmA7XG5mdW5jdGlvbiBkZWZhdWx0R3JvdXBSZW5kZXJlcjxUPihlOiBBY2NvcmRpb25Hcm91cFJlbmRlckV2ZW50PFQ+KTogUmVhY3QuUmVhY3RDaGlsZCB7XG4gICAgcmV0dXJuICg8PlxuICAgICAge2UuZ3JvdXAgPyBlLmdyb3VwLnRvU3RyaW5nKCkgOiBlLmdyb3VwfSAoe2UuaXRlbXMubGVuZ3RofSlcbiAgICA8Lz4pO1xufVxuZXhwb3J0IGNsYXNzIEFjY29yZGlvblRhYmxlQmFzaWM8VD4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8QWNjb3JkaW9uVGFibGVQcm9wczxUPiwgQWNjb3JkaW9uVGFibGVCYXNpY1N0YXRlPiB7XG4gICAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICBub1ZhbHVlR3JvdXBMYWJlbDogJ+KAlCcsXG4gICAgfTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogQWNjb3JkaW9uVGFibGVQcm9wczxUPikge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZWREZXRhaWxzID0gcHJvcHMuc2VsZWN0ZWRJbmRleCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBjb250cm9sbGVkR3JvdXBzID0gQXJyYXkuaXNBcnJheShwcm9wcy5leHBhbmRlZEdyb3Vwcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4OiBub3JtYWxpemVJbmRleChwcm9wcy5zZWxlY3RlZEluZGV4KSxcbiAgICAgICAgICAgIGNvbnRyb2xsZWRJbmRleDogY29udHJvbGxlZERldGFpbHMsXG4gICAgICAgICAgICBjb250cm9sbGVkR3JvdXBzOiBjb250cm9sbGVkR3JvdXBzLFxuICAgICAgICAgICAgZXhwYW5kZWRHcm91cHM6IGNvbnRyb2xsZWRHcm91cHMgPyBwcm9wcy5leHBhbmRlZEdyb3VwcyB8fCBbXSA6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBBY2NvcmRpb25UYWJsZVByb3BzPGFueT4sIHN0YXRlOiBBY2NvcmRpb25UYWJsZUJhc2ljU3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3RlZEluZGV4LCBleHBhbmRlZEdyb3VwcyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gc3RhdGUuY29udHJvbGxlZEluZGV4ICYmIHNlbGVjdGVkSW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbmV3R3JvdXBzID0gc3RhdGUuY29udHJvbGxlZEdyb3VwcyAmJiBleHBhbmRlZEdyb3VwcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobmV3SW5kZXggfHwgbmV3R3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IG5ld0luZGV4ID8gbm9ybWFsaXplSW5kZXgoc2VsZWN0ZWRJbmRleCkgOiBzdGF0ZS5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICAgIGV4cGFuZGVkR3JvdXBzOiBuZXdHcm91cHMgPyBleHBhbmRlZEdyb3VwcyA6IHN0YXRlLmV4cGFuZGVkR3JvdXBzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHByaXZhdGUgZ2V0R3JvdXBJdGVtczxUPihkYXRhOiBBcnJheTxUPiwgZ3JvdXBCeT86IGtleW9mIFQsIGdyb3VwPzogYW55KSB7XG4gICAgICAgIGNvbnN0IHsgbm9WYWx1ZUdyb3VwTGFiZWwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChncm91cEJ5KSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAgPT09IG5vVmFsdWVHcm91cExhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZmlsdGVyKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1bZ3JvdXBCeV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBudW1iZXIgJzAnIHNob3VsZG4ndCBiZSBpbiB0aGUgbm8tdmFsdWUtZ3JvdXAuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSBhcnJheXMgc2hvdWxkIGJlIGluIHRoZSBuby12YWx1ZS1ncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF2YWx1ZSB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZmlsdGVyKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1bZ3JvdXBCeV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXlzIGlzIG5lZWRlZCBiZWNhdXNlICc9PT0nIGRvZXNuJ3Qgd29yayBmb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShncm91cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSA9PT0gZ3JvdXAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcHJpdmF0ZSBoYW5kbGVDbGljayh0YXJnZXQ6IG51bWJlciwgZGF0YTogVCkge1xuICAgICAgICBjb25zdCB7IG9uQ2hhbmdlLCBtdWx0aXBsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBjb250cm9sbGVkSW5kZXgsIHNlbGVjdGVkSW5kZXggfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleGVzID0gdG9nZ2xlSW5kZXgoc2VsZWN0ZWRJbmRleCwgdGFyZ2V0LCBtdWx0aXBsZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4OiBtdWx0aXBsZSA/IG5leHRJbmRleGVzIDogbmV4dEluZGV4ZXNbMF0gIT09IHVuZGVmaW5lZCA/IG5leHRJbmRleGVzWzBdIDogLTEsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNJbmRleDogbXVsdGlwbGUgPyBzZWxlY3RlZEluZGV4IDogc2VsZWN0ZWRJbmRleFswXSAhPT0gdW5kZWZpbmVkID8gc2VsZWN0ZWRJbmRleFswXSA6IC0xLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRyb2xsZWRJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleDogbmV4dEluZGV4ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIHRvZ2dsZUdyb3VwKGdyb3VwOiBhbnkpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBvblRvZ2dsZUdyb3VwLCBncm91cEJ5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGV4cGFuZGVkR3JvdXBzLCBjb250cm9sbGVkR3JvdXBzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAodHlwZW9mIG9uVG9nZ2xlR3JvdXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uVG9nZ2xlR3JvdXAoe1xuICAgICAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdleHBhbmQnLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiB0aGlzLmdldEdyb3VwSXRlbXMoZGF0YSwgZ3JvdXBCeSwgZ3JvdXApLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250cm9sbGVkR3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAoZXhwYW5kZWRHcm91cHMuaW5kZXhPZihncm91cCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkR3JvdXBzOiBleHBhbmRlZEdyb3Vwcy5maWx0ZXIobSA9PiBtICE9PSBncm91cCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRHcm91cHM6IFsuLi5leHBhbmRlZEdyb3VwcywgZ3JvdXBdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgZ3JvdXBSZW5kZXJlcihncm91cDogYW55LCBjb3VudDogbnVtYmVyLCBleHBhbmRlZDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCB7IHRoZW1lLCBncm91cFJlbmRlcmVyID0gZGVmYXVsdEdyb3VwUmVuZGVyZXIsIGRhdGEsIGdyb3VwQnkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRHcm91cEl0ZW1zKGRhdGEsIGdyb3VwQnksIGdyb3VwKTtcbiAgICAgICAgcmV0dXJuICg8PlxuICAgICAgICA8QWNjb3JkaW9uVGFibGVSb3cgY2xpY2thYmxlIG9uQ2xpY2s9eygpID0+IHRoaXMudG9nZ2xlR3JvdXAoZ3JvdXApfSB0aGVtZT17dGhlbWV9PlxuICAgICAgICAgIDxHcm91cFRhYmxlQ2VsbD5cbiAgICAgICAgICAgIDxTdHlsZWRJY29uIGlzUm90YXRlZD17ZXhwYW5kZWR9IG5hbWU9XCJLZXlib2FyZEFycm93UmlnaHRcIi8+XG4gICAgICAgICAgPC9Hcm91cFRhYmxlQ2VsbD5cbiAgICAgICAgICA8R3JvdXBUYWJsZUNlbGwgY29sU3Bhbj17Y291bnQgLSAxfT57Z3JvdXBSZW5kZXJlcih7IGV4cGFuZGVkLCBncm91cCwgaXRlbXMgfSl9PC9Hcm91cFRhYmxlQ2VsbD5cbiAgICAgICAgPC9BY2NvcmRpb25UYWJsZVJvdz5cbiAgICAgICAgPFN0eWxlZFRhYmxlUm93Q29sbGFwc2UgLz5cbiAgICAgIDwvPik7XG4gICAgfVxuICAgIHByaXZhdGUgZ2V0R3JvdXBCeVZhbHVlID0gKHJvd0RhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB7IGdyb3VwQnksIG5vVmFsdWVHcm91cExhYmVsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoZ3JvdXBCeSkge1xuICAgICAgICAgICAgY29uc3Qgcm93VmFsdWUgPSByb3dEYXRhW2dyb3VwQnldO1xuICAgICAgICAgICAgaWYgKHJvd1ZhbHVlIHx8IHJvd1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93VmFsdWUpICYmIHJvd1ZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9WYWx1ZUdyb3VwTGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vVmFsdWVHcm91cExhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBoZWxwZXIgbWV0aG9kIHRvIGNoZWNrIGlmIGFuIGVsZW1lbnQgaXMgaW5jbHVkZWQgaW4gYW4gYXJyYXkuXG4gICAgICogVGhpcyBtZXRob2QgaGFzIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5cyBvZiBhcnJheXMuIEluIHRoaXMgY2FzZSBub3JtYWwgc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nICg9PT0pXG4gICAgICogd291bGRuJ3Qgd29yay5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBhcnJheUluY2x1ZGVzPEU+KGVsZW1lbnQ6IEUsIGFycjogQXJyYXk8RT4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICgoQXJyYXkuaXNBcnJheShlbGVtZW50KSA/IEpTT04uc3RyaW5naWZ5KGFycikuaW5kZXhPZihKU09OLnN0cmluZ2lmeShlbGVtZW50KSkgOiBhcnIuaW5kZXhPZihlbGVtZW50KSkgIT09IC0xKTtcbiAgICB9XG4gICAgcHJpdmF0ZSByb3dSZW5kZXJlciA9ICh7IGNlbGxzLCBpbmRleCwgZGF0YSwga2V5LCBzdGF0ZSB9OiBUYWJsZVJvd0V2ZW50PFQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsc1JlbmRlcmVyLCByb3dSZW5kZXJlciwgdGhlbWUsIGFycm93VG9nZ2xlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGVkSW5kZXgsIGV4cGFuZGVkR3JvdXBzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGdyb3VwZWRSb3dzID0gW10gfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSBoYXNJbmRleChzZWxlY3RlZEluZGV4LCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gUmVhY3QuQ2hpbGRyZW4uY291bnQoY2VsbHMpO1xuICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldEdyb3VwQnlWYWx1ZShkYXRhKTtcbiAgICAgICAgY29uc3Qgb3BlbiA9ICEoY29sIHx8IGNvbCA9PT0gMCkgfHwgQWNjb3JkaW9uVGFibGVCYXNpYy5hcnJheUluY2x1ZGVzKGNvbCwgZXhwYW5kZWRHcm91cHMpO1xuICAgICAgICBjb25zdCByZW5kZXJEYXRhID0geyBjZWxscywgaW5kZXgsIGRhdGEsIGFjdGl2ZSwga2V5LCBzdGF0ZSB9O1xuICAgICAgICBjb25zdCBpc05ld0dyb3VwID0gKGNvbCB8fCBjb2wgPT09IDApICYmICFBY2NvcmRpb25UYWJsZUJhc2ljLmFycmF5SW5jbHVkZXMoY29sLCBncm91cGVkUm93cyk7XG4gICAgICAgIGlmIChpc05ld0dyb3VwKSB7XG4gICAgICAgICAgICBzdGF0ZS5ncm91cGVkUm93cyA9IFsuLi5ncm91cGVkUm93cywgY29sXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxSZWFjdC5GcmFnbWVudCBrZXk9e2tleX0+XG4gICAgICAgIHtpc05ld0dyb3VwICYmIHRoaXMuZ3JvdXBSZW5kZXJlcihjb2wsIGNvdW50LCBvcGVuKX1cbiAgICAgICAge29wZW4gJiYgKDw+XG4gICAgICAgICAgICB7KHJvd1JlbmRlcmVyICYmIHJvd1JlbmRlcmVyKHJlbmRlckRhdGEpKSB8fCAoPEFjY29yZGlvblRhYmxlUm93IGFjdGl2ZT17YWN0aXZlfSBjbGlja2FibGU9eyFhcnJvd1RvZ2dsZX0gb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVDbGljayhpbmRleCwgZGF0YSl9IHRoZW1lPXt0aGVtZX0+XG4gICAgICAgICAgICAgICAge2NlbGxzfVxuICAgICAgICAgICAgICA8L0FjY29yZGlvblRhYmxlUm93Pil9XG4gICAgICAgICAgICA8U3R5bGVkVGFibGVSb3dDb2xsYXBzZSBhY3RpdmU9e2FjdGl2ZX0+XG4gICAgICAgICAgICAgIDxTdHlsZWREZXRhaWxzQ29udGFpbmVyIGNvbFNwYW49e2NvdW50fT5cbiAgICAgICAgICAgICAgICA8U3R5bGVkQ29sbGFwc2VBbmltYXRvciBhY3RpdmU9e2FjdGl2ZX0+XG4gICAgICAgICAgICAgICAgICB7YWN0aXZlICYmIGRldGFpbHNSZW5kZXJlciAmJiBkZXRhaWxzUmVuZGVyZXIoeyBpbmRleCwgZGF0YSB9KX1cbiAgICAgICAgICAgICAgICA8L1N0eWxlZENvbGxhcHNlQW5pbWF0b3I+XG4gICAgICAgICAgICAgIDwvU3R5bGVkRGV0YWlsc0NvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvU3R5bGVkVGFibGVSb3dDb2xsYXBzZT5cbiAgICAgICAgICA8Lz4pfVxuICAgICAgPC9SZWFjdC5GcmFnbWVudD4pO1xuICAgIH07XG4gICAgcHJpdmF0ZSBjZWxsUmVuZGVyZXIgPSAoZTogVGFibGVDZWxsUmVuZGVyRXZlbnQ8VD4pID0+IHtcbiAgICAgICAgY29uc3QgeyByb3csIGRhdGEgfSA9IGU7XG4gICAgICAgIGlmIChlLmNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICg8U3R5bGVkSWNvbiBpc1JvdGF0ZWQ9e2hhc0luZGV4KHRoaXMuc3RhdGUuc2VsZWN0ZWRJbmRleCwgcm93KX0gbmFtZT1cIktleWJvYXJkQXJyb3dSaWdodFwiIG9uQ2xpY2s9eygpID0+IGRhdGEgJiYgdGhpcy5oYW5kbGVDbGljayhyb3csIGRhdGEpfS8+KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNlbGxSZW5kZXJlciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjZWxsUmVuZGVyZXIgPT09ICdmdW5jdGlvbicgPyBjZWxsUmVuZGVyZXIoZSkgOiBkZWZhdWx0Q2VsbFJlbmRlcmVyKGUpO1xuICAgIH07XG4gICAgcHJpdmF0ZSBnZXRDb2x1bW5zKCkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGNvbHVtbnMsIGluZGV4ZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChjb2x1bW5zIHx8IChkYXRhICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgICAgY29uc3QgY29scyA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6ICcnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVtQ2FsYygnNTBweCcpLFxuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGNvbHNbJyMnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiAnIycsXG4gICAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNvbHVtbnMgfHwgZGF0YVswXSk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBjb2x1bW5zID8gY29sdW1uc1trZXldIDoga2V5O1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBjb2xzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBkZXRhaWxzUmVuZGVyZXI6IF8wLCBjb2x1bW5zOiBfMSwgaW5kZXhlZDogXzIsIGdyb3VwUmVuZGVyZXI6IF8zLCBleHBhbmRlZEdyb3VwczogXzQsIG9uVG9nZ2xlR3JvdXA6IF81LCBvcGVuTGFiZWw6IF82LCBjbG9zZUxhYmVsOiBfNywgbXVsdGlwbGU6IF84LCAuLi5wcm9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuICg8U3R5bGVkVGFibGUgey4uLnByb3BzfSBtb2RlPVwidGFibGVcIiBjb2x1bW5zPXt0aGlzLmdldENvbHVtbnMoKX0gcm93UmVuZGVyZXI9e3RoaXMucm93UmVuZGVyZXJ9IGNlbGxSZW5kZXJlcj17dGhpcy5jZWxsUmVuZGVyZXJ9Lz4pO1xuICAgIH1cbiAgICBzdGF0aWMgaW5uZXIgPSB7XG4gICAgICAgIGdldCBBY2NvcmRpb25UYWJsZVJvdygpIHsgcmV0dXJuIEFjY29yZGlvblRhYmxlUm93IGFzIHR5cGVvZiBBY2NvcmRpb25UYWJsZVJvdzsgfSxcbiAgICAgICAgZ2V0IEdyb3VwVGFibGVDZWxsKCkgeyByZXR1cm4gR3JvdXBUYWJsZUNlbGwgYXMgdHlwZW9mIEdyb3VwVGFibGVDZWxsOyB9LFxuICAgICAgICBnZXQgU3R5bGVkSWNvbigpIHsgcmV0dXJuIFN0eWxlZEljb24gYXMgdHlwZW9mIFN0eWxlZEljb247IH0sXG4gICAgICAgIGdldCBTdHlsZWRUYWJsZVJvd0NvbGxhcHNlKCkgeyByZXR1cm4gU3R5bGVkVGFibGVSb3dDb2xsYXBzZSBhcyB0eXBlb2YgU3R5bGVkVGFibGVSb3dDb2xsYXBzZTsgfSxcbiAgICAgICAgZ2V0IFN0eWxlZERldGFpbHNDb250YWluZXIoKSB7IHJldHVybiBTdHlsZWREZXRhaWxzQ29udGFpbmVyIGFzIHR5cGVvZiBTdHlsZWREZXRhaWxzQ29udGFpbmVyOyB9LFxuICAgICAgICBnZXQgU3R5bGVkQ29sbGFwc2VBbmltYXRvcigpIHsgcmV0dXJuIFN0eWxlZENvbGxhcHNlQW5pbWF0b3IgYXMgdHlwZW9mIFN0eWxlZENvbGxhcHNlQW5pbWF0b3I7IH0sXG4gICAgICAgIGdldCBTdHlsZWRUYWJsZSgpIHsgcmV0dXJuIFN0eWxlZFRhYmxlIGFzIHR5cGVvZiBTdHlsZWRUYWJsZTsgfVxuICAgIH07XG59XG4iXX0=
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var withInner_1 = require("typescript-plugin-inner-jsx/withInner");
/**
 * Wraps the component in a responsive construct that is sensitive to the size changes of its
 * container.
 * @param Component The component to be sensitive to its container dimensions.
 * @returns A component that can use the `dimensions` prop.
 */
function withResponsive(Component) {
    return withInner_1.withInner(/** @class */ (function (_super) {
        __extends(Responsive, _super);
        function Responsive(props) {
            var _this = _super.call(this, props) || this;
            _this.sizeChanged = function () {
                var _a = _this.getDimension(), width = _a.width, height = _a.height;
                if (width !== _this.state.width || height !== _this.state.height) {
                    _this.setState({
                        width: width,
                        height: height,
                    });
                }
            };
            _this.orientationChanged = function () { return _this.setState({
                angle: (screen.orientation && screen.orientation.angle) || 0,
            }); };
            _this.setNode = function (node) { return (_this.node = node); };
            var screenWithOrientaion = screen;
            _this.state = {
                width: window.innerWidth,
                height: window.innerHeight,
                angle: (screenWithOrientaion.orientation && screenWithOrientaion.orientation.angle) || 0,
            };
            return _this;
        }
        Responsive.prototype.componentDidMount = function () {
            window.addEventListener('resize', this.sizeChanged);
            window.addEventListener('orientationchange', this.orientationChanged);
        };
        Responsive.prototype.componentWillUnmount = function () {
            window.removeEventListener('resize', this.sizeChanged);
            window.removeEventListener('orientationchange', this.orientationChanged);
        };
        Responsive.prototype.getDimension = function () {
            if (this.node) {
                var boundingClientRect = this.node.getBoundingClientRect();
                return {
                    width: boundingClientRect.width,
                    height: boundingClientRect.height,
                };
            }
            else {
                var innerWidth_1 = window.innerWidth, innerHeight_1 = window.innerHeight;
                return {
                    width: innerWidth_1,
                    height: innerHeight_1,
                };
            }
        };
        Responsive.prototype.render = function () {
            var additionalProps = {
                innerRef: this.setNode,
                dimensions: this.state,
            };
            var props = __assign({}, this.props, additionalProps);
            return React.createElement(Component, __assign({}, props));
        };
        return Responsive;
    }(React.Component)), { Component: Component });
}
exports.withResponsive = withResponsive;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l0aFJlc3BvbnNpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvaG9jL3dpdGhSZXNwb25zaXZlLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZCQUErQjtBQUUvQixtRUFBa0U7QUFxQmxFOzs7OztHQUtHO0FBQ0gsU0FBZ0IsY0FBYyxDQUEwQyxTQUFzQztJQUMxRyxPQUFPLHFCQUFTO1FBQTBCLDhCQUFpRDtRQUV2RixvQkFBWSxLQUFhO1lBQXpCLFlBQ0ksa0JBQU0sS0FBSyxDQUFDLFNBV2Y7WUF5QkQsaUJBQVcsR0FBRztnQkFDSixJQUFBLHlCQUF1QyxFQUFyQyxnQkFBSyxFQUFFLGtCQUE4QixDQUFDO2dCQUM5QyxJQUFJLEtBQUssS0FBSyxLQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxNQUFNLEtBQUssS0FBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7b0JBQzVELEtBQUksQ0FBQyxRQUFRLENBQUM7d0JBQ1YsS0FBSyxPQUFBO3dCQUNMLE1BQU0sUUFBQTtxQkFDVCxDQUFDLENBQUM7aUJBQ047WUFDTCxDQUFDLENBQUM7WUFDRix3QkFBa0IsR0FBRyxjQUFNLE9BQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQztnQkFDckMsS0FBSyxFQUFFLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7YUFDL0QsQ0FBQyxFQUZ5QixDQUV6QixDQUFDO1lBQ0gsYUFBTyxHQUFHLFVBQUMsSUFBd0IsSUFBSyxPQUFBLENBQUMsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQztZQS9DdkQsSUFBTSxvQkFBb0IsR0FBRyxNQUk1QixDQUFDO1lBQ0YsS0FBSSxDQUFDLEtBQUssR0FBRztnQkFDVCxLQUFLLEVBQUUsTUFBTSxDQUFDLFVBQVU7Z0JBQ3hCLE1BQU0sRUFBRSxNQUFNLENBQUMsV0FBVztnQkFDMUIsS0FBSyxFQUFFLENBQUMsb0JBQW9CLENBQUMsV0FBVyxJQUFJLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO2FBQzNGLENBQUM7O1FBQ04sQ0FBQztRQUNELHNDQUFpQixHQUFqQjtZQUNJLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3BELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUMxRSxDQUFDO1FBQ0QseUNBQW9CLEdBQXBCO1lBQ0ksTUFBTSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDdkQsTUFBTSxDQUFDLG1CQUFtQixDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzdFLENBQUM7UUFDRCxpQ0FBWSxHQUFaO1lBQ0ksSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNYLElBQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2dCQUM3RCxPQUFPO29CQUNILEtBQUssRUFBRSxrQkFBa0IsQ0FBQyxLQUFLO29CQUMvQixNQUFNLEVBQUUsa0JBQWtCLENBQUMsTUFBTTtpQkFDcEMsQ0FBQzthQUNMO2lCQUNJO2dCQUNPLElBQUEsZ0NBQVUsRUFBRSxrQ0FBVyxDQUFZO2dCQUMzQyxPQUFPO29CQUNILEtBQUssRUFBRSxZQUFVO29CQUNqQixNQUFNLEVBQUUsYUFBVztpQkFDdEIsQ0FBQzthQUNMO1FBQ0wsQ0FBQztRQWNELDJCQUFNLEdBQU47WUFDSSxJQUFNLGVBQWUsR0FBNkI7Z0JBQzlDLFFBQVEsRUFBRSxJQUFJLENBQUMsT0FBTztnQkFDdEIsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLO2FBQ3pCLENBQUM7WUFDRixJQUFNLEtBQUssZ0JBQVEsSUFBSSxDQUFDLEtBQUssRUFBSyxlQUFlLENBQUUsQ0FBQztZQUNwRCxPQUFPLG9CQUFDLFNBQVMsZUFBSyxLQUFLLEVBQUcsQ0FBQztRQUNuQyxDQUFDO1FBQ0wsaUJBQUM7SUFBRCxDQUFDLEFBNURnQixDQUF5QixLQUFLLENBQUMsU0FBUyxJQTREdEQsRUFBRSxTQUFTLFdBQUEsRUFBRSxDQUFDLENBQUM7QUFDdEIsQ0FBQztBQTlERCx3Q0E4REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSZWZQcm9wcyB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyB3aXRoSW5uZXIgfSBmcm9tICd0eXBlc2NyaXB0LXBsdWdpbi1pbm5lci1qc3gvd2l0aElubmVyJztcbmV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2l2ZUNvbXBvbmVudFByb3BzIGV4dGVuZHMgUmVmUHJvcHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBkaW1lbnNpb25zIHZhbHVlcyBjb250YWluZXJcbiAgICAgKi9cbiAgICBkaW1lbnNpb25zPzogUmVzcG9uc2l2ZUNvbXBvbmVudFN0YXRlO1xufVxuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zaXZlQ29tcG9uZW50U3RhdGUge1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2NyZWVuIHJvdGF0aW9uIGluIGRlZ3JlZXMuXG4gICAgICovXG4gICAgYW5nbGU6IG51bWJlcjtcbn1cbi8qKlxuICogV3JhcHMgdGhlIGNvbXBvbmVudCBpbiBhIHJlc3BvbnNpdmUgY29uc3RydWN0IHRoYXQgaXMgc2Vuc2l0aXZlIHRvIHRoZSBzaXplIGNoYW5nZXMgb2YgaXRzXG4gKiBjb250YWluZXIuXG4gKiBAcGFyYW0gQ29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gYmUgc2Vuc2l0aXZlIHRvIGl0cyBjb250YWluZXIgZGltZW5zaW9ucy5cbiAqIEByZXR1cm5zIEEgY29tcG9uZW50IHRoYXQgY2FuIHVzZSB0aGUgYGRpbWVuc2lvbnNgIHByb3AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoUmVzcG9uc2l2ZTxUUHJvcHMgZXh0ZW5kcyBSZXNwb25zaXZlQ29tcG9uZW50UHJvcHM+KENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxUUHJvcHM+KTogUmVhY3QuQ29tcG9uZW50Q2xhc3M8VFByb3BzPiB7XG4gICAgcmV0dXJuIHdpdGhJbm5lcihjbGFzcyBSZXNwb25zaXZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFRQcm9wcywgUmVzcG9uc2l2ZUNvbXBvbmVudFN0YXRlPiB7XG4gICAgICAgIG5vZGU6IEhUTUxFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgY29uc3RydWN0b3IocHJvcHM6IFRQcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgY29uc3Qgc2NyZWVuV2l0aE9yaWVudGFpb24gPSBzY3JlZW4gYXMge1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uPzoge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZTogbnVtYmVyO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgYW5nbGU6IChzY3JlZW5XaXRoT3JpZW50YWlvbi5vcmllbnRhdGlvbiAmJiBzY3JlZW5XaXRoT3JpZW50YWlvbi5vcmllbnRhdGlvbi5hbmdsZSkgfHwgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5zaXplQ2hhbmdlZCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLm9yaWVudGF0aW9uQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5zaXplQ2hhbmdlZCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLm9yaWVudGF0aW9uQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGltZW5zaW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kaW5nQ2xpZW50UmVjdCA9IHRoaXMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYm91bmRpbmdDbGllbnRSZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQgfSA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbm5lckhlaWdodCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpemVDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmdldERpbWVuc2lvbigpO1xuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLnN0YXRlLndpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5zdGF0ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb3JpZW50YXRpb25DaGFuZ2VkID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBhbmdsZTogKHNjcmVlbi5vcmllbnRhdGlvbiAmJiBzY3JlZW4ub3JpZW50YXRpb24uYW5nbGUpIHx8IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBzZXROb2RlID0gKG5vZGU6IEhUTUxFbGVtZW50IHwgbnVsbCkgPT4gKHRoaXMubm9kZSA9IG5vZGUpO1xuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsUHJvcHM6IFJlc3BvbnNpdmVDb21wb25lbnRQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBpbm5lclJlZjogdGhpcy5zZXROb2RlLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB7IC4uLnRoaXMucHJvcHMsIC4uLmFkZGl0aW9uYWxQcm9wcyB9O1xuICAgICAgICAgICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnByb3BzfS8+O1xuICAgICAgICB9XG4gICAgfSwgeyBDb21wb25lbnQgfSk7XG59XG4iXX0=
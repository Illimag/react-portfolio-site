"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var withInner_1 = require("typescript-plugin-inner-jsx/withInner");
/**
 * Provides automatic validation for a wrapped component.
 * @param validate The validation function.
 * @returns A constructor function taking a component to be wrapped with the validation.
 */
function withValidation(validate) {
    return function (Component) {
        return withInner_1.withInner(/** @class */ (function (_super) {
            __extends(Validator, _super);
            function Validator(props) {
                var _this = _super.call(this, props) || this;
                _this.validate = function (e) {
                    var _a = _this.props, onChange = _a.onChange, onError = _a.onError, onSuccess = _a.onSuccess;
                    var error = validate(e);
                    if (error !== _this.state.error) {
                        var notify = error ? onError : onSuccess;
                        _this.setState({
                            error: error,
                        });
                        if (typeof notify === 'function') {
                            notify();
                        }
                    }
                    if (typeof onChange === 'function') {
                        onChange(e);
                    }
                };
                _this.state = {
                    error: undefined,
                };
                return _this;
            }
            Validator.prototype.render = function () {
                var _a = this.state.error, error = _a === void 0 ? this.props.error : _a;
                return React.createElement(Component, __assign({}, this.props, { error: error, onChange: this.validate }));
            };
            return Validator;
        }(React.PureComponent)), { Component: Component });
    };
}
exports.withValidation = withValidation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l0aFZhbGlkYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvaG9jL3dpdGhWYWxpZGF0aW9uLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZCQUErQjtBQUMvQixtRUFBa0U7QUFrQmxFOzs7O0dBSUc7QUFDSCxTQUFnQixjQUFjLENBQWEsUUFBeUQ7SUFDaEcsT0FBTyxVQUE0QyxTQUFzQztRQUNyRixPQUFPLHFCQUFTO1lBQXlCLDZCQUE0RDtZQUNqRyxtQkFBWSxLQUE4QjtnQkFBMUMsWUFDSSxrQkFBTSxLQUFLLENBQUMsU0FJZjtnQkFDRCxjQUFRLEdBQUcsVUFBQyxDQUFhO29CQUNmLElBQUEsZ0JBQTZDLEVBQTNDLHNCQUFRLEVBQUUsb0JBQU8sRUFBRSx3QkFBd0IsQ0FBQztvQkFDcEQsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMxQixJQUFJLEtBQUssS0FBSyxLQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTt3QkFDNUIsSUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQzt3QkFDM0MsS0FBSSxDQUFDLFFBQVEsQ0FBQzs0QkFDVixLQUFLLE9BQUE7eUJBQ1IsQ0FBQyxDQUFDO3dCQUNILElBQUksT0FBTyxNQUFNLEtBQUssVUFBVSxFQUFFOzRCQUM5QixNQUFNLEVBQUUsQ0FBQzt5QkFDWjtxQkFDSjtvQkFDRCxJQUFJLE9BQU8sUUFBUSxLQUFLLFVBQVUsRUFBRTt3QkFDaEMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNmO2dCQUNMLENBQUMsQ0FBQztnQkFuQkUsS0FBSSxDQUFDLEtBQUssR0FBRztvQkFDVCxLQUFLLEVBQUUsU0FBUztpQkFDbkIsQ0FBQzs7WUFDTixDQUFDO1lBaUJELDBCQUFNLEdBQU47Z0JBQ1ksSUFBQSxxQkFBd0IsRUFBeEIsNkNBQXdCLENBQWdCO2dCQUNoRCxPQUFPLG9CQUFDLFNBQVMsZUFBSyxJQUFJLENBQUMsS0FBSyxJQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLElBQUcsQ0FBQztZQUMvRSxDQUFDO1lBQ0wsZ0JBQUM7UUFBRCxDQUFDLEFBM0JnQixDQUF3QixLQUFLLENBQUMsYUFBYSxJQTJCekQsRUFBRSxTQUFTLFdBQUEsRUFBRSxDQUFDLENBQUM7SUFDdEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQS9CRCx3Q0ErQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB3aXRoSW5uZXIgfSBmcm9tICd0eXBlc2NyaXB0LXBsdWdpbi1pbm5lci1qc3gvd2l0aElubmVyJztcbmV4cG9ydCBpbnRlcmZhY2UgQmFzZUlucHV0UHJvcHM8VEV2ZW50QXJncz4ge1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGVtaXR0ZWQgb25jZSB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBvbkNoYW5nZT8oZTogVEV2ZW50QXJncyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBlcnJvcj86IFJlYWN0LlJlYWN0Q2hpbGQ7XG59XG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRvclByb3BzIHtcbiAgICBvblN1Y2Nlc3M/KCk6IHZvaWQ7XG4gICAgb25FcnJvcj8oKTogdm9pZDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdG9yU3RhdGUge1xuICAgIGVycm9yOiBSZWFjdC5SZWFjdENoaWxkIHwgdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhdXRvbWF0aWMgdmFsaWRhdGlvbiBmb3IgYSB3cmFwcGVkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB2YWxpZGF0ZSBUaGUgdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIEEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGFraW5nIGEgY29tcG9uZW50IHRvIGJlIHdyYXBwZWQgd2l0aCB0aGUgdmFsaWRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhWYWxpZGF0aW9uPFRFdmVudEFyZ3M+KHZhbGlkYXRlOiAoZTogVEV2ZW50QXJncykgPT4gUmVhY3QuUmVhY3RDaGlsZCB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiA8VFByb3BzIGV4dGVuZHMgQmFzZUlucHV0UHJvcHM8VEV2ZW50QXJncz4+KENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxUUHJvcHM+KSA9PiB7XG4gICAgICAgIHJldHVybiB3aXRoSW5uZXIoY2xhc3MgVmFsaWRhdG9yIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxUUHJvcHMgJiBWYWxpZGF0b3JQcm9wcywgVmFsaWRhdG9yU3RhdGU+IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByb3BzOiBUUHJvcHMgJiBWYWxpZGF0b3JQcm9wcykge1xuICAgICAgICAgICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0ZSA9IChlOiBURXZlbnRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvbkNoYW5nZSwgb25FcnJvciwgb25TdWNjZXNzIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdmFsaWRhdGUoZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICE9PSB0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGlmeSA9IGVycm9yID8gb25FcnJvciA6IG9uU3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90aWZ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciA9IHRoaXMucHJvcHMuZXJyb3IgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnRoaXMucHJvcHN9IGVycm9yPXtlcnJvcn0gb25DaGFuZ2U9e3RoaXMudmFsaWRhdGV9Lz47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgQ29tcG9uZW50IH0pO1xuICAgIH07XG59XG4iXX0=
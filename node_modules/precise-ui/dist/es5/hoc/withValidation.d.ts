import * as React from 'react';
export interface BaseInputProps<TEventArgs> {
    /**
     * Event emitted once the value changes.
     */
    onChange?(e: TEventArgs): void;
    /**
     * The currently displayed error message.
     */
    error?: React.ReactChild;
}
export interface ValidatorProps {
    onSuccess?(): void;
    onError?(): void;
}
export interface ValidatorState {
    error: React.ReactChild | undefined;
}
/**
 * Provides automatic validation for a wrapped component.
 * @param validate The validation function.
 * @returns A constructor function taking a component to be wrapped with the validation.
 */
export declare function withValidation<TEventArgs>(validate: (e: TEventArgs) => React.ReactChild | undefined): <TProps extends BaseInputProps<TEventArgs>>(Component: React.ComponentType<TProps>) => {
    new (props: TProps & ValidatorProps): {
        validate: (e: TEventArgs) => void;
        render(): JSX.Element;
        context: any;
        setState<K extends "error">(state: ValidatorState | ((prevState: Readonly<ValidatorState>, props: Readonly<TProps & ValidatorProps>) => ValidatorState | Pick<ValidatorState, K> | null) | Pick<ValidatorState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callBack?: (() => void) | undefined): void;
        readonly props: Readonly<React.PropsWithChildren<TProps & ValidatorProps>>;
        state: Readonly<ValidatorState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
    };
    contextType?: React.Context<any> | undefined;
} & {
    inner: Readonly<{
        Component: React.ComponentType<TProps>;
    }>;
};

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var PdfJsApi = require('pdfjs-dist');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var PdfJsApi__namespace = /*#__PURE__*/_interopNamespace(PdfJsApi);

exports.AnnotationType = void 0;
(function (AnnotationType) {
    AnnotationType[AnnotationType["Text"] = 1] = "Text";
    AnnotationType[AnnotationType["Link"] = 2] = "Link";
    AnnotationType[AnnotationType["FreeText"] = 3] = "FreeText";
    AnnotationType[AnnotationType["Line"] = 4] = "Line";
    AnnotationType[AnnotationType["Square"] = 5] = "Square";
    AnnotationType[AnnotationType["Circle"] = 6] = "Circle";
    AnnotationType[AnnotationType["Polygon"] = 7] = "Polygon";
    AnnotationType[AnnotationType["Polyline"] = 8] = "Polyline";
    AnnotationType[AnnotationType["Highlight"] = 9] = "Highlight";
    AnnotationType[AnnotationType["Underline"] = 10] = "Underline";
    AnnotationType[AnnotationType["Squiggly"] = 11] = "Squiggly";
    AnnotationType[AnnotationType["StrikeOut"] = 12] = "StrikeOut";
    AnnotationType[AnnotationType["Stamp"] = 13] = "Stamp";
    AnnotationType[AnnotationType["Caret"] = 14] = "Caret";
    AnnotationType[AnnotationType["Ink"] = 15] = "Ink";
    AnnotationType[AnnotationType["Popup"] = 16] = "Popup";
    AnnotationType[AnnotationType["FileAttachment"] = 17] = "FileAttachment";
})(exports.AnnotationType || (exports.AnnotationType = {}));

exports.LayerRenderStatus = void 0;
(function (LayerRenderStatus) {
    LayerRenderStatus[LayerRenderStatus["PreRender"] = 0] = "PreRender";
    LayerRenderStatus[LayerRenderStatus["DidRender"] = 1] = "DidRender";
})(exports.LayerRenderStatus || (exports.LayerRenderStatus = {}));

exports.Position = void 0;
(function (Position) {
    Position["TopLeft"] = "TOP_LEFT";
    Position["TopCenter"] = "TOP_CENTER";
    Position["TopRight"] = "TOP_RIGHT";
    Position["RightTop"] = "RIGHT_TOP";
    Position["RightCenter"] = "RIGHT_CENTER";
    Position["RightBottom"] = "RIGHT_BOTTOM";
    Position["BottomLeft"] = "BOTTOM_LEFT";
    Position["BottomCenter"] = "BOTTOM_CENTER";
    Position["BottomRight"] = "BOTTOM_RIGHT";
    Position["LeftTop"] = "LEFT_TOP";
    Position["LeftCenter"] = "LEFT_CENTER";
    Position["LeftBottom"] = "LEFT_BOTTOM";
})(exports.Position || (exports.Position = {}));

exports.SpecialZoomLevel = void 0;
(function (SpecialZoomLevel) {
    SpecialZoomLevel["ActualSize"] = "ActualSize";
    SpecialZoomLevel["PageFit"] = "PageFit";
    SpecialZoomLevel["PageWidth"] = "PageWidth";
})(exports.SpecialZoomLevel || (exports.SpecialZoomLevel = {}));

exports.ToggleStatus = void 0;
(function (ToggleStatus) {
    ToggleStatus["Close"] = "Close";
    ToggleStatus["Open"] = "Open";
    ToggleStatus["Toggle"] = "Toggle";
})(exports.ToggleStatus || (exports.ToggleStatus = {}));

var Button = function (_a) {
    var children = _a.children, onClick = _a.onClick;
    return (React__namespace.createElement("button", { className: "rpv-core__button", type: "button", onClick: onClick }, children));
};

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;

var Menu = function (_a) {
    var children = _a.children;
    var containerRef = React__namespace.useRef();
    var visibleMenuItemsRef = React__namespace.useRef([]);
    var handleKeyDown = function (e) {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        switch (e.key) {
            case 'Tab':
                e.preventDefault();
                break;
            case 'ArrowDown':
                e.preventDefault();
                moveToItem(function (_, currentIndex) { return currentIndex + 1; });
                break;
            case 'ArrowUp':
                e.preventDefault();
                moveToItem(function (_, currentIndex) { return currentIndex - 1; });
                break;
            case 'End':
                e.preventDefault();
                moveToItem(function (items, _) { return items.length - 1; });
                break;
            case 'Home':
                e.preventDefault();
                moveToItem(function (_, __) { return 0; });
                break;
        }
    };
    var moveToItem = function (getNextItem) {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        var items = visibleMenuItemsRef.current;
        var currentIndex = items.findIndex(function (item) { return item.getAttribute('tabindex') === '0'; });
        var targetIndex = Math.min(items.length - 1, Math.max(0, getNextItem(items, currentIndex)));
        if (currentIndex >= 0 && currentIndex <= items.length - 1) {
            items[currentIndex].setAttribute('tabindex', '-1');
        }
        items[targetIndex].setAttribute('tabindex', '0');
        items[targetIndex].focus();
    };
    var findVisibleItems = function (container) {
        var visibleItems = [];
        container.querySelectorAll('.rpv-core__menu-item[role="menuitem"]').forEach(function (item) {
            if (item instanceof HTMLElement) {
                var parent_1 = item.parentElement;
                if (parent_1 === container) {
                    visibleItems.push(item);
                }
                else {
                    if (window.getComputedStyle(parent_1).display !== 'none') {
                        visibleItems.push(item);
                    }
                }
            }
        });
        return visibleItems;
    };
    useIsomorphicLayoutEffect(function () {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        var visibleItems = findVisibleItems(container);
        visibleMenuItemsRef.current = visibleItems;
    }, []);
    useIsomorphicLayoutEffect(function () {
        document.addEventListener('keydown', handleKeyDown);
        return function () {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, []);
    return (React__namespace.createElement("div", { ref: containerRef, "aria-orientation": "vertical", className: "rpv-core__menu", role: "menu", tabIndex: 0 }, children));
};

var MenuDivider = function () { return (React__namespace.createElement("div", { "aria-orientation": "horizontal", className: "rpv-core__menu-divider", role: "separator" })); };

var Icon = function (_a) {
    var children = _a.children, _b = _a.size, size = _b === void 0 ? 24 : _b;
    var width = (size || 24) + "px";
    return (React__namespace.createElement("svg", { "aria-hidden": "true", className: "rpv-core__icon", focusable: "false", height: width, viewBox: "0 0 24 24", width: width }, children));
};

var CheckIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M23.5,0.499l-16.5,23l-6.5-6.5" }))); };

var classNames = function (classes) {
    var result = [];
    Object.keys(classes).forEach(function (clazz) {
        if (clazz && classes[clazz]) {
            result.push(clazz);
        }
    });
    return result.join(' ');
};

var MenuItem = function (_a) {
    var _b = _a.checked, checked = _b === void 0 ? false : _b, children = _a.children, _c = _a.icon, icon = _c === void 0 ? null : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, onClick = _a.onClick;
    return (React__namespace.createElement("button", { className: classNames({
            'rpv-core__menu-item': true,
            'rpv-core__menu-item--disabled': isDisabled,
        }), role: "menuitem", tabIndex: -1, type: "button", onClick: onClick },
        React__namespace.createElement("div", { className: "rpv-core__menu-item-icon" }, icon),
        React__namespace.createElement("div", { className: "rpv-core__menu-item-label" }, children),
        React__namespace.createElement("div", { className: "rpv-core__menu-item-check" }, checked && React__namespace.createElement(CheckIcon, null))));
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var MinimalButton = function (_a) {
    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.ariaKeyShortcuts, ariaKeyShortcuts = _c === void 0 ? '' : _c, children = _a.children, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.isSelected, isSelected = _e === void 0 ? false : _e, onClick = _a.onClick;
    return (React__namespace.createElement("button", __assign({ "aria-label": ariaLabel }, (ariaKeyShortcuts && { 'aria-keyshortcuts': ariaKeyShortcuts }), (isDisabled && { 'aria-disabled': true }), { className: classNames({
            'rpv-core__minimal-button': true,
            'rpv-core__minimal-button--disabled': isDisabled,
            'rpv-core__minimal-button--selected': isSelected,
        }), type: "button", onClick: onClick }), children));
};

var PrimaryButton = function (_a) {
    var children = _a.children, onClick = _a.onClick;
    return (React__namespace.createElement("button", { className: "rpv-core__primary-button", type: "button", onClick: onClick }, children));
};

var ProgressBar = function (_a) {
    var progress = _a.progress;
    return (React__namespace.createElement("div", { className: "rpv-core__progress-bar" },
        React__namespace.createElement("div", { className: "rpv-core__progress-bar-progress", style: { width: progress + "%" } },
            progress,
            "%")));
};

var Separator = function () { return React__namespace.createElement("div", { className: "rpv-core__separator" }); };

var Spinner = function (_a) {
    var _b = _a.size, size = _b === void 0 ? '4rem' : _b;
    return React__namespace.createElement("div", { className: "rpv-core__spinner", style: { height: size, width: size } });
};

var TextBox = function (_a) {
    var _b = _a.ariaLabel, ariaLabel = _b === void 0 ? '' : _b, _c = _a.placeholder, placeholder = _c === void 0 ? '' : _c, _d = _a.type, type = _d === void 0 ? 'text' : _d, _e = _a.value, value = _e === void 0 ? '' : _e, onChange = _a.onChange, _f = _a.onKeyDown, onKeyDown = _f === void 0 ? function () { } : _f;
    return (React__namespace.createElement("input", { "aria-label": ariaLabel, className: "rpv-core__textbox", placeholder: placeholder, type: type, value: value, onChange: function (e) { return onChange(e.target.value); }, onKeyDown: onKeyDown }));
};

var useClickOutside = function (closeOnClickOutside, targetRef, onClickOutside) {
    var clickHandler = function (e) {
        var target = targetRef.current;
        if (target && !target.contains(e.target)) {
            onClickOutside();
        }
    };
    React__namespace.useEffect(function () {
        if (!closeOnClickOutside) {
            return;
        }
        document.addEventListener('click', clickHandler);
        return function () {
            document.removeEventListener('click', clickHandler);
        };
    }, []);
};

var useEscape = function (handler) {
    var keyUpHandler = function (e) {
        if (e.key === 'Escape') {
            handler();
        }
    };
    React__namespace.useEffect(function () {
        document.addEventListener('keyup', keyUpHandler);
        return function () {
            document.removeEventListener('keyup', keyUpHandler);
        };
    }, []);
};

var useLockScroll = function () {
    React__namespace.useEffect(function () {
        var originalStyle = window.getComputedStyle(document.body).overflow;
        document.body.style.overflow = 'hidden';
        return function () {
            document.body.style.overflow = originalStyle;
        };
    }, []);
};

var ModalBody = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, onToggle = _a.onToggle;
    var contentRef = React__namespace.useRef();
    useLockScroll();
    useEscape(function () {
        if (contentRef.current && closeOnEscape) {
            onToggle();
        }
    });
    useClickOutside(closeOnClickOutside, contentRef, onToggle);
    useIsomorphicLayoutEffect(function () {
        var contentEle = contentRef.current;
        if (!contentEle) {
            return;
        }
        var maxHeight = document.body.clientHeight * 0.75;
        if (contentEle.getBoundingClientRect().height >= maxHeight) {
            contentEle.style.overflow = 'auto';
            contentEle.style.maxHeight = maxHeight + "px";
        }
    }, []);
    return (React__namespace.createElement("div", { "aria-modal": "true", className: "rpv-core__modal-body", id: "rpv-core__modal-body-" + ariaControlsSuffix, ref: contentRef, role: "dialog", tabIndex: -1 }, children));
};

var ModalOverlay = function (_a) {
    var children = _a.children;
    return React__namespace.createElement("div", { className: "rpv-core__modal-overlay" }, children);
};

var useToggle = function () {
    var _a = React__namespace.useState(false), opened = _a[0], setOpened = _a[1];
    var toggle = function (status) {
        switch (status) {
            case exports.ToggleStatus.Close:
                setOpened(false);
                break;
            case exports.ToggleStatus.Open:
                setOpened(true);
                break;
            case exports.ToggleStatus.Toggle:
            default:
                setOpened(function (isOpened) { return !isOpened; });
                break;
        }
    };
    return { opened: opened, toggle: toggle };
};

var Portal = function (_a) {
    var content = _a.content, target = _a.target;
    var _b = useToggle(), opened = _b.opened, toggle = _b.toggle;
    return (React__namespace.createElement(React__namespace.Fragment, null,
        target(toggle, opened),
        opened && content(toggle)));
};

var id = 0;
var uniqueId = function () { return id++; };

var Modal = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, target = _a.target;
    var controlsSuffix = ariaControlsSuffix || "" + uniqueId();
    var renderTarget = function (toggle, opened) { return (React__namespace.createElement("div", { "aria-expanded": opened ? 'true' : 'false', "aria-haspopup": "dialog", "aria-controls": "rpv-core__modal-body-" + controlsSuffix }, target(toggle, opened))); };
    var renderContent = function (toggle) { return (React__namespace.createElement(ModalOverlay, null,
        React__namespace.createElement(ModalBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, closeOnEscape: closeOnEscape, onToggle: toggle }, content(toggle)))); };
    return React__namespace.createElement(Portal, { target: renderTarget, content: renderContent });
};

var calculatePosition = function (content, target, position, offset) {
    var targetRect = target.getBoundingClientRect();
    var contentRect = content.getBoundingClientRect();
    var height = contentRect.height, width = contentRect.width;
    var top = 0;
    var left = 0;
    switch (position) {
        case exports.Position.TopLeft:
            top = targetRect.top - height;
            left = targetRect.left;
            break;
        case exports.Position.TopCenter:
            top = targetRect.top - height;
            left = targetRect.left + targetRect.width / 2 - width / 2;
            break;
        case exports.Position.TopRight:
            top = targetRect.top - height;
            left = targetRect.left + targetRect.width - width;
            break;
        case exports.Position.RightTop:
            top = targetRect.top;
            left = targetRect.left + targetRect.width;
            break;
        case exports.Position.RightCenter:
            top = targetRect.top + targetRect.height / 2 - height / 2;
            left = targetRect.left + targetRect.width;
            break;
        case exports.Position.RightBottom:
            top = targetRect.top + targetRect.height - height;
            left = targetRect.left + targetRect.width;
            break;
        case exports.Position.BottomLeft:
            top = targetRect.top + targetRect.height;
            left = targetRect.left;
            break;
        case exports.Position.BottomCenter:
            top = targetRect.top + targetRect.height;
            left = targetRect.left + targetRect.width / 2 - width / 2;
            break;
        case exports.Position.BottomRight:
            top = targetRect.top + targetRect.height;
            left = targetRect.left + targetRect.width - width;
            break;
        case exports.Position.LeftTop:
            top = targetRect.top;
            left = targetRect.left - width;
            break;
        case exports.Position.LeftCenter:
            top = targetRect.top + targetRect.height / 2 - height / 2;
            left = targetRect.left - width;
            break;
        case exports.Position.LeftBottom:
            top = targetRect.top + targetRect.height - height;
            left = targetRect.left - width;
            break;
    }
    return {
        left: left + (offset.left || 0),
        top: top + (offset.top || 0),
    };
};

var usePosition = function (contentRef, targetRef, anchorRef, position, offset) {
    useIsomorphicLayoutEffect(function () {
        var targetEle = targetRef.current;
        var contentEle = contentRef.current;
        var anchorEle = anchorRef.current;
        if (!contentEle || !targetEle || !anchorEle) {
            return;
        }
        var anchorRect = anchorEle.getBoundingClientRect();
        var _a = calculatePosition(contentEle, targetEle, position, offset), top = _a.top, left = _a.left;
        contentEle.style.top = top - anchorRect.top + "px";
        contentEle.style.left = left - anchorRect.left + "px";
    }, []);
};

var Arrow = function (_a) {
    var _b;
    var customClassName = _a.customClassName, position = _a.position;
    return (React__namespace.createElement("div", { className: classNames((_b = {
                'rpv-core__arrow': true,
                'rpv-core__arrow--tl': position === exports.Position.TopLeft,
                'rpv-core__arrow--tc': position === exports.Position.TopCenter,
                'rpv-core__arrow--tr': position === exports.Position.TopRight,
                'rpv-core__arrow--rt': position === exports.Position.RightTop,
                'rpv-core__arrow--rc': position === exports.Position.RightCenter,
                'rpv-core__arrow--rb': position === exports.Position.RightBottom,
                'rpv-core__arrow--bl': position === exports.Position.BottomLeft,
                'rpv-core__arrow--bc': position === exports.Position.BottomCenter,
                'rpv-core__arrow--br': position === exports.Position.BottomRight,
                'rpv-core__arrow--lt': position === exports.Position.LeftTop,
                'rpv-core__arrow--lc': position === exports.Position.LeftCenter,
                'rpv-core__arrow--lb': position === exports.Position.LeftBottom
            },
            _b["" + customClassName] = customClassName !== '',
            _b)) }));
};

var PopoverBody = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, closeOnClickOutside = _a.closeOnClickOutside, offset = _a.offset, position = _a.position, targetRef = _a.targetRef, onClose = _a.onClose;
    var contentRef = React__namespace.useRef();
    var innerRef = React__namespace.useRef();
    var anchorRef = React__namespace.useRef();
    useClickOutside(closeOnClickOutside, contentRef, onClose);
    usePosition(contentRef, targetRef, anchorRef, position, offset);
    useIsomorphicLayoutEffect(function () {
        var innerContentEle = innerRef.current;
        if (!innerContentEle) {
            return;
        }
        var maxHeight = document.body.clientHeight * 0.75;
        if (innerContentEle.getBoundingClientRect().height >= maxHeight) {
            innerContentEle.style.overflow = 'auto';
            innerContentEle.style.maxHeight = maxHeight + "px";
        }
    }, []);
    var innerId = "rpv-core__popover-body-inner-" + ariaControlsSuffix;
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),
        React__namespace.createElement("div", { "aria-describedby": innerId, className: "rpv-core__popover-body", id: "rpv-core__popover-body-" + ariaControlsSuffix, ref: contentRef, role: "dialog", tabIndex: -1 },
            React__namespace.createElement(Arrow, { customClassName: "rpv-core__popover-body-arrow", position: position }),
            React__namespace.createElement("div", { id: innerId, ref: innerRef }, children))));
};

var PopoverOverlay = function (_a) {
    var closeOnEscape = _a.closeOnEscape, onClose = _a.onClose;
    var containerRef = React__namespace.useRef();
    useEscape(function () {
        if (containerRef.current && closeOnEscape) {
            onClose();
        }
    });
    return React__namespace.createElement("div", { className: "rpv-core__popover-overlay", ref: containerRef });
};

var Popover = function (_a) {
    var _b = _a.ariaHasPopup, ariaHasPopup = _b === void 0 ? 'dialog' : _b, ariaControlsSuffix = _a.ariaControlsSuffix, closeOnClickOutside = _a.closeOnClickOutside, closeOnEscape = _a.closeOnEscape, content = _a.content, offset = _a.offset, position = _a.position, target = _a.target;
    var _c = useToggle(), opened = _c.opened, toggle = _c.toggle;
    var targetRef = React__namespace.useRef();
    var controlsSuffix = ariaControlsSuffix || "" + uniqueId();
    return (React__namespace.createElement("div", { ref: targetRef, "aria-expanded": opened ? 'true' : 'false', "aria-haspopup": ariaHasPopup, "aria-controls": "rpv-core__popver-body-" + controlsSuffix },
        target(toggle, opened),
        opened && (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement(PopoverOverlay, { closeOnEscape: closeOnEscape, onClose: toggle }),
            React__namespace.createElement(PopoverBody, { ariaControlsSuffix: controlsSuffix, closeOnClickOutside: closeOnClickOutside, offset: offset, position: position, targetRef: targetRef, onClose: toggle }, content(toggle))))));
};

var TooltipBody = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, children = _a.children, contentRef = _a.contentRef, offset = _a.offset, position = _a.position, targetRef = _a.targetRef;
    var anchorRef = React__namespace.useRef();
    usePosition(contentRef, targetRef, anchorRef, position, offset);
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", { ref: anchorRef, style: { left: 0, position: 'absolute', top: 0 } }),
        React__namespace.createElement("div", { className: "rpv-core__tooltip-body", id: "rpv-core__tooltip-body-" + ariaControlsSuffix, ref: contentRef, role: "tooltip" },
            React__namespace.createElement(Arrow, { customClassName: "rpv-core__tooltip-body-arrow", position: position }),
            React__namespace.createElement("div", { className: "rpv-core__tooltip-body-content" }, children))));
};

var Tooltip = function (_a) {
    var ariaControlsSuffix = _a.ariaControlsSuffix, content = _a.content, offset = _a.offset, position = _a.position, target = _a.target;
    var _b = useToggle(), opened = _b.opened, toggle = _b.toggle;
    var targetRef = React__namespace.useRef();
    var contentRef = React__namespace.useRef();
    var controlsSuffix = ariaControlsSuffix || "" + uniqueId();
    useEscape(function () {
        if (targetRef.current && document.activeElement && targetRef.current.contains(document.activeElement)) {
            close();
        }
    });
    var open = function () {
        toggle(exports.ToggleStatus.Open);
    };
    var close = function () {
        toggle(exports.ToggleStatus.Close);
    };
    var onBlur = function (e) {
        var shouldHideTooltip = e.relatedTarget instanceof HTMLElement &&
            e.currentTarget.parentElement &&
            e.currentTarget.parentElement.contains(e.relatedTarget);
        if (shouldHideTooltip) {
            if (contentRef.current) {
                contentRef.current.style.display = 'none';
            }
        }
        else {
            close();
        }
    };
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", { ref: targetRef, "aria-describedby": "rpv-core__tooltip-body-" + controlsSuffix, onBlur: onBlur, onFocus: open, onMouseEnter: open, onMouseLeave: close }, target),
        opened && (React__namespace.createElement(TooltipBody, { ariaControlsSuffix: controlsSuffix, contentRef: contentRef, offset: offset, position: position, targetRef: targetRef }, content()))));
};

function createStore(initialState) {
    var state = initialState || {};
    var listeners = {};
    return {
        subscribe: function (key, handler) {
            listeners[key] = (listeners[key] || []).concat(handler);
        },
        unsubscribe: function (key, handler) {
            listeners[key] = (listeners[key] || []).filter(function (f) { return f !== handler; });
        },
        update: function (key, data) {
            var _a;
            state = __assign(__assign({}, state), (_a = {}, _a[key] = data, _a));
            (listeners[key] || []).forEach(function (handler) { return handler(state[key]); });
        },
        get: function (key) {
            return state[key];
        },
    };
}

var LocalizationContext = React__namespace.createContext({});

var core = {
	askingPassword: {
		requirePasswordToOpen: "This document requires a password to open",
		submit: "Submit"
	},
	wrongPassword: {
		submit: "Submit",
		tryAgain: "The password is wrong. Please try again"
	},
	pageLabel: "Page {{pageIndex}}"
};
var enUs = {
	core: core
};

var LocalizationProvider = function (_a) {
    var children = _a.children, localization = _a.localization;
    var defaultL10n = enUs;
    var _b = React__namespace.useState(localization || defaultL10n), l10nData = _b[0], setL10nData = _b[1];
    var setLocalization = function (l10n) { return setL10nData(l10n); };
    return React__namespace.createElement(LocalizationContext.Provider, { value: l10nData }, children(setLocalization));
};

var ThemeContext = React__namespace.createContext({
    currentTheme: 'light',
    setCurrentTheme: function () { },
});

function usePrevious(value) {
    var ref = React__namespace.useRef(value);
    React__namespace.useEffect(function () {
        ref.current = value;
    }, [value]);
    return ref.current;
}

var isDarkMode = function () {
    return typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
};

var ThemeProvider = function (_a) {
    var children = _a.children, theme = _a.theme, onSwitchTheme = _a.onSwitchTheme;
    var initialTheme = React__namespace.useMemo(function () { return (theme === 'auto' ? (isDarkMode() ? 'dark' : 'light') : theme); }, []);
    var _b = React__namespace.useState(initialTheme), currentTheme = _b[0], setCurrentTheme = _b[1];
    var prevTheme = usePrevious(currentTheme);
    React__namespace.useEffect(function () {
        if (theme !== 'auto') {
            return;
        }
        var media = window.matchMedia('(prefers-color-scheme: dark)');
        var handler = function (e) {
            setCurrentTheme(e.matches ? 'dark' : 'light');
        };
        media.addEventListener('change', handler);
        return function () { return media.removeEventListener('change', handler); };
    }, []);
    React__namespace.useEffect(function () {
        if (currentTheme !== prevTheme && onSwitchTheme) {
            onSwitchTheme(currentTheme);
        }
    }, [currentTheme]);
    var initialContext = {
        currentTheme: currentTheme,
        setCurrentTheme: setCurrentTheme,
    };
    return React__namespace.createElement(ThemeContext.Provider, { value: initialContext }, children);
};

var useIntersectionObserver = function (props) {
    var containerRef = React__namespace.useRef(null);
    var threshold = props.threshold, onVisibilityChanged = props.onVisibilityChanged;
    useIsomorphicLayoutEffect(function () {
        var io = new IntersectionObserver(function (entries) {
            entries.forEach(function (entry) {
                var isVisible = entry.isIntersecting;
                var ratio = entry.intersectionRatio;
                onVisibilityChanged({ isVisible: isVisible, ratio: ratio });
            });
        }, {
            threshold: threshold || 0,
        });
        var container = containerRef.current;
        if (!container) {
            return;
        }
        io.observe(container);
        return function () {
            io.unobserve(container);
        };
    }, []);
    return containerRef;
};

var AnnotationBorderStyleType;
(function (AnnotationBorderStyleType) {
    AnnotationBorderStyleType[AnnotationBorderStyleType["Solid"] = 1] = "Solid";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Dashed"] = 2] = "Dashed";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Beveled"] = 3] = "Beveled";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Inset"] = 4] = "Inset";
    AnnotationBorderStyleType[AnnotationBorderStyleType["Underline"] = 5] = "Underline";
})(AnnotationBorderStyleType || (AnnotationBorderStyleType = {}));

var dateRegex = new RegExp('^D:' +
    '(\\d{4})' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '(\\d{2})?' +
    '([Z|+|-])?' +
    '(\\d{2})?' +
    "'?" +
    '(\\d{2})?' +
    "'?");
var parse$1 = function (value, min, max, defaultValue) {
    var parsed = parseInt(value, 10);
    return parsed >= min && parsed <= max ? parsed : defaultValue;
};
var convertDate = function (input) {
    var matches = dateRegex.exec(input);
    if (!matches) {
        return null;
    }
    var year = parseInt(matches[1], 10);
    var month = parse$1(matches[2], 1, 12, 1) - 1;
    var day = parse$1(matches[3], 1, 31, 1);
    var hour = parse$1(matches[4], 0, 23, 0);
    var minute = parse$1(matches[5], 0, 59, 0);
    var second = parse$1(matches[6], 0, 59, 0);
    var universalTimeRelation = matches[7] || 'Z';
    var offsetHour = parse$1(matches[8], 0, 23, 0);
    var offsetMinute = parse$1(matches[9], 0, 59, 0);
    switch (universalTimeRelation) {
        case '-':
            hour += offsetHour;
            minute += offsetMinute;
            break;
        case '+':
            hour -= offsetHour;
            minute -= offsetMinute;
            break;
    }
    return new Date(Date.UTC(year, month, day, hour, minute, second));
};

var PopupWrapper = function (_a) {
    var annotation = _a.annotation;
    var containerRef = React__namespace.useRef();
    var dateStr = '';
    if (annotation.modificationDate) {
        var date = convertDate(annotation.modificationDate);
        dateStr = date ? date.toLocaleDateString() + ", " + date.toLocaleTimeString() : '';
    }
    React__namespace.useLayoutEffect(function () {
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        var annotationEle = document.querySelector("[data-annotation-id=\"" + annotation.id + "\"]");
        if (!annotationEle) {
            return;
        }
        var ele = annotationEle;
        ele.style.zIndex += 1;
        return function () {
            ele.style.zIndex = "" + (parseInt(ele.style.zIndex, 10) - 1);
        };
    }, []);
    return (React__namespace.createElement("div", { ref: containerRef, className: "rpv-core__annotation-popup-wrapper", style: {
            top: annotation.annotationType === exports.AnnotationType.Popup ? '' : '100%',
        } },
        annotation.title && (React__namespace.createElement("div", { className: "rpv-core__annotation-popup-header" },
            React__namespace.createElement("div", { className: "rpv-core__annotation-popup-title" }, annotation.title),
            React__namespace.createElement("span", { className: "rpv-core__annotation-popup-date" }, dateStr))),
        annotation.contents && (React__namespace.createElement("div", { className: "rpv-core__annotation-popup-content" }, annotation.contents.split('\n').map(function (item, index) { return (React__namespace.createElement(React__namespace.Fragment, { key: index },
            item,
            React__namespace.createElement("br", null))); })))));
};

var TogglePopupBy;
(function (TogglePopupBy) {
    TogglePopupBy["Click"] = "Click";
    TogglePopupBy["Hover"] = "Hover";
})(TogglePopupBy || (TogglePopupBy = {}));
var useTogglePopup = function () {
    var _a = useToggle(), opened = _a.opened, toggle = _a.toggle;
    var _b = React__namespace.useState(TogglePopupBy.Hover), togglePopupBy = _b[0], setTooglePopupBy = _b[1];
    var toggleOnClick = function () {
        switch (togglePopupBy) {
            case TogglePopupBy.Click:
                opened && setTooglePopupBy(TogglePopupBy.Hover);
                toggle(exports.ToggleStatus.Toggle);
                break;
            case TogglePopupBy.Hover:
                setTooglePopupBy(TogglePopupBy.Click);
                toggle(exports.ToggleStatus.Open);
                break;
        }
    };
    var openOnHover = function () {
        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Open);
    };
    var closeOnHover = function () {
        togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Close);
    };
    return {
        opened: opened,
        closeOnHover: closeOnHover,
        openOnHover: openOnHover,
        toggleOnClick: toggleOnClick,
    };
};

var Annotation = function (_a) {
    var annotation = _a.annotation, children = _a.children, ignoreBorder = _a.ignoreBorder, hasPopup = _a.hasPopup, isRenderable = _a.isRenderable, page = _a.page, viewport = _a.viewport;
    var rect = annotation.rect;
    var _b = useTogglePopup(), closeOnHover = _b.closeOnHover, opened = _b.opened, openOnHover = _b.openOnHover, toggleOnClick = _b.toggleOnClick;
    var normalizeRect = function (r) { return [
        Math.min(r[0], r[2]),
        Math.min(r[1], r[3]),
        Math.max(r[0], r[2]),
        Math.max(r[1], r[3]),
    ]; };
    var bound = normalizeRect([
        rect[0],
        page.view[3] + page.view[1] - rect[1],
        rect[2],
        page.view[3] + page.view[1] - rect[3],
    ]);
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var styles = {
        borderColor: '',
        borderRadius: '',
        borderStyle: '',
        borderWidth: '',
    };
    if (!ignoreBorder && annotation.borderStyle.width > 0) {
        switch (annotation.borderStyle.style) {
            case AnnotationBorderStyleType.Dashed:
                styles.borderStyle = 'dashed';
                break;
            case AnnotationBorderStyleType.Solid:
                styles.borderStyle = 'solid';
                break;
            case AnnotationBorderStyleType.Underline:
                styles = Object.assign({
                    borderBottomStyle: 'solid',
                }, styles);
                break;
            case AnnotationBorderStyleType.Beveled:
            case AnnotationBorderStyleType.Inset:
        }
        var borderWidth = annotation.borderStyle.width;
        styles.borderWidth = borderWidth + "px";
        if (annotation.borderStyle.style !== AnnotationBorderStyleType.Underline) {
            width = width - 2 * borderWidth;
            height = height - 2 * borderWidth;
        }
        var _c = annotation.borderStyle, horizontalCornerRadius = _c.horizontalCornerRadius, verticalCornerRadius = _c.verticalCornerRadius;
        if (horizontalCornerRadius > 0 || verticalCornerRadius > 0) {
            styles.borderRadius = horizontalCornerRadius + "px / " + verticalCornerRadius + "px";
        }
        annotation.color
            ? (styles.borderColor = "rgb(" + (annotation.color[0] | 0) + ", " + (annotation.color[1] | 0) + ", " + (annotation.color[2] | 0) + ")")
            :
                (styles.borderWidth = '0');
    }
    return (React__namespace.createElement(React__namespace.Fragment, null, isRenderable &&
        children({
            popup: {
                opened: opened,
                closeOnHover: closeOnHover,
                openOnHover: openOnHover,
                toggleOnClick: toggleOnClick,
            },
            slot: {
                attrs: {
                    style: Object.assign({
                        height: height + "px",
                        left: bound[0] + "px",
                        top: bound[1] + "px",
                        transform: "matrix(" + viewport.transform.join(',') + ")",
                        transformOrigin: "-" + bound[0] + "px -" + bound[1] + "px",
                        width: width + "px",
                    }, styles),
                },
                children: React__namespace.createElement(React__namespace.Fragment, null, hasPopup && opened && React__namespace.createElement(PopupWrapper, { annotation: annotation })),
            },
        })));
};

var Caret = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--caret", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var Circle = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--circle", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        React__namespace.createElement("svg", { height: height + "px", preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 " + width + " " + height, width: width + "px" },
            React__namespace.createElement("circle", { cy: height / 2, fill: "none", rx: width / 2 - borderWidth / 2, ry: height / 2 - borderWidth / 2, stroke: "transparent", strokeWidth: borderWidth || 1 })),
        props.slot.children)); }));
};

var getFileName = function (url) {
    var str = url.split('/').pop();
    return str ? str.split('#')[0].split('?')[0] : url;
};

var downloadFile = function (url, data) {
    var blobUrl = typeof data === 'string' ? '' : URL.createObjectURL(new Blob([data], { type: '' }));
    var link = document.createElement('a');
    link.style.display = 'none';
    link.href = blobUrl || url;
    link.setAttribute('download', getFileName(url));
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    if (blobUrl) {
        URL.revokeObjectURL(blobUrl);
    }
};

var FileAttachment = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false && (!!annotation.title || !!annotation.contents);
    var doubleClick = function () {
        var file = annotation.file;
        file && downloadFile(file.filename, file.content);
    };
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: true, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--file-attachment", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onDoubleClick: doubleClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var FreeText = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--free-text", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var Popup = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var isRenderable = !!(annotation.title || annotation.contents);
    var ignoredParents = ['Circle', 'Ink', 'Line', 'Polygon', 'PolyLine', 'Square'];
    var hasPopup = !annotation.parentType || ignoredParents.indexOf(annotation.parentType) !== -1;
    useIsomorphicLayoutEffect(function () {
        if (!annotation.parentId) {
            return;
        }
        var parent = document.querySelector("[data-annotation-id=\"" + annotation.parentId + "\"]");
        var container = document.querySelector("[data-annotation-id=\"" + annotation.id + "\"]");
        if (!parent || !container) {
            return;
        }
        var left = parseFloat(parent.style.left);
        var top = parseFloat(parent.style.top) + parseFloat(parent.style.height);
        container.style.left = left + "px";
        container.style.top = top + "px";
        container.style.transformOrigin = "-" + left + "px -" + top + "px";
    }, []);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--popup", "data-annotation-id": annotation.id }),
        React__namespace.createElement(PopupWrapper, { annotation: annotation }))); }));
};

var Highlight = function (_a) {
    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var hasQuadPoints = annotation.quadPoints && annotation.quadPoints.length > 0;
    if (hasQuadPoints) {
        var annotations = annotation.quadPoints.map(function (quadPoint) {
            return Object.assign({}, annotation, {
                rect: [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y],
                quadPoints: [],
            });
        });
        return (React__namespace.createElement(React__namespace.Fragment, null, annotations.map(function (ann, index) { return (React__namespace.createElement(Highlight, { key: index, annotation: ann, childAnnotation: childAnnotation, page: page, viewport: viewport })); })));
    }
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--highlight", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children),
        childAnnotation &&
            childAnnotation.annotationType === exports.AnnotationType.Popup &&
            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));
};

var Ink = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--ink", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        annotation.inkLists && annotation.inkLists.length && (React__namespace.createElement("svg", { height: height + "px", preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 " + width + " " + height, width: width + "px" }, annotation.inkLists.map(function (inkList, index) { return (React__namespace.createElement("polyline", { key: index, fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, points: inkList.map(function (item) { return item.x - rect[0] + "," + (rect[3] - item.y); }).join(' ') })); }))),
        props.slot.children)); }));
};

var Line = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--line", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        React__namespace.createElement("svg", { height: height + "px", preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 " + width + " " + height, width: width + "px" },
            React__namespace.createElement("line", { stroke: "transparent", strokeWidth: borderWidth || 1, x1: rect[2] - annotation.lineCoordinates[0], x2: rect[2] - annotation.lineCoordinates[2], y1: rect[3] - annotation.lineCoordinates[1], y2: rect[3] - annotation.lineCoordinates[3] })),
        props.slot.children)); }));
};

var parse = function (pageIndex, destArray) {
    var bottomOffset;
    var scale;
    switch (destArray[1].name) {
        case 'XYZ':
            bottomOffset = destArray[3];
            scale = destArray[4];
            return {
                bottomOffset: bottomOffset,
                pageIndex: pageIndex - 1,
                scaleTo: scale,
            };
        case 'Fit':
        case 'FitB':
            return {
                bottomOffset: 0,
                pageIndex: pageIndex - 1,
                scaleTo: exports.SpecialZoomLevel.PageFit,
            };
        case 'FitH':
        case 'FitBH':
            return {
                bottomOffset: destArray[2],
                pageIndex: pageIndex - 1,
                scaleTo: exports.SpecialZoomLevel.PageWidth,
            };
        default:
            return {
                bottomOffset: 0,
                pageIndex: pageIndex - 1,
                scaleTo: 1,
            };
    }
};
var getDestination = function (doc, dest) {
    return new Promise(function (res) {
        new Promise(function (resolve) {
            if (typeof dest === 'string') {
                doc.getDestination(dest).then(function (destArray) {
                    resolve(destArray);
                });
            }
            else {
                resolve(dest);
            }
        })
            .then(function (destArray) {
            return 'object' === typeof destArray[0]
                ? doc.getPageIndex(destArray[0]).then(function (pageIndex) { return Promise.resolve({ pageIndex: pageIndex, destArray: destArray }); })
                : Promise.resolve({
                    pageIndex: destArray[0],
                    destArray: destArray,
                });
        })
            .then(function (_a) {
            var pageIndex = _a.pageIndex, destArray = _a.destArray;
            var target = parse(pageIndex, destArray);
            res(target);
        });
    });
};

var Link = function (_a) {
    var annotation = _a.annotation, doc = _a.doc, page = _a.page, viewport = _a.viewport, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest;
    var link = function (e) {
        e.preventDefault();
        annotation.action
            ? onExecuteNamedAction(annotation.action)
            : getDestination(doc, annotation.dest).then(function (target) {
                var pageIndex = target.pageIndex, bottomOffset = target.bottomOffset, scaleTo = target.scaleTo;
                onJumpToDest(bottomOffset ? pageIndex + 1 : pageIndex, bottomOffset, 0, scaleTo);
            });
    };
    var isRenderable = !!(annotation.url || annotation.dest || annotation.action);
    var attrs = annotation.url
        ? {
            href: annotation.url,
            rel: 'noopener noreferrer nofollow',
            target: annotation.newWindow ? '_blank' : '',
            title: annotation.url,
        }
        : {
            href: '',
            'data-annotation-link-dest': annotation.dest,
            onClick: link,
        };
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: false, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--link", "data-annotation-id": annotation.id }),
        React__namespace.createElement("a", __assign({}, attrs)))); }));
};

var Polygon = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polygon", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        annotation.vertices && annotation.vertices.length && (React__namespace.createElement("svg", { height: height + "px", preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 " + width + " " + height, width: width + "px" },
            React__namespace.createElement("polygon", { fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, points: annotation.vertices
                    .map(function (item) { return item.x - rect[0] + "," + (rect[3] - item.y); })
                    .join(' ') }))),
        props.slot.children)); }));
};

var Polyline = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polyline", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        annotation.vertices && annotation.vertices.length && (React__namespace.createElement("svg", { height: height + "px", preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 " + width + " " + height, width: width + "px" },
            React__namespace.createElement("polyline", { fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, points: annotation.vertices
                    .map(function (item) { return item.x - rect[0] + "," + (rect[3] - item.y); })
                    .join(' ') }))),
        props.slot.children)); }));
};

var Square = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var rect = annotation.rect;
    var width = rect[2] - rect[0];
    var height = rect[3] - rect[1];
    var borderWidth = annotation.borderStyle.width;
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--square", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
        React__namespace.createElement("svg", { height: height + "px", preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 " + width + " " + height, width: width + "px" },
            React__namespace.createElement("rect", { height: height - borderWidth, fill: "none", stroke: "transparent", strokeWidth: borderWidth || 1, x: borderWidth / 2, y: borderWidth / 2, width: width - borderWidth })),
        props.slot.children)); }));
};

var Squiggly = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--squiggly", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var Stamp = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--stamp", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var StrikeOut = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--strike-out", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var CommentIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z" }),
    React__namespace.createElement("path", { d: "M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25" }),
    React__namespace.createElement("path", { d: "M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75" }),
    React__namespace.createElement("path", { d: "M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25" }))); };

var HelpIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z" }),
    React__namespace.createElement("path", { d: "M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z" }),
    React__namespace.createElement("path", { d: "M21.423 5.406L17.415 9.414" }),
    React__namespace.createElement("path", { d: "M14.587 6.585L18.607 2.565" }),
    React__namespace.createElement("path", { d: "M5.405 21.424L9.413 17.416" }),
    React__namespace.createElement("path", { d: "M6.585 14.588L2.577 18.596" }),
    React__namespace.createElement("path", { d: "M18.602 21.419L14.595 17.412" }),
    React__namespace.createElement("path", { d: "M17.419 14.58L21.428 18.589" }),
    React__namespace.createElement("path", { d: "M2.582 5.399L6.588 9.406" }),
    React__namespace.createElement("path", { d: "M9.421 6.581L5.412 2.572" }))); };

var KeyIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z" }),
    React__namespace.createElement("path", { d: "M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z" }))); };

var NoteIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z" }),
    React__namespace.createElement("path", { d: "M6 4.5L6 0.5" }),
    React__namespace.createElement("path", { d: "M18 4.5L18 0.5" }),
    React__namespace.createElement("path", { d: "M10 4.5L10 0.5" }),
    React__namespace.createElement("path", { d: "M14 4.5L14 0.5" }))); };

var ParagraphIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M17.5 0.498L17.5 23.498" }),
    React__namespace.createElement("path", { d: "M10.5 0.498L10.5 23.498" }),
    React__namespace.createElement("path", { d: "M23.5.5H6.5a6,6,0,0,0,0,12h4" }))); };

var TriangleIcon = function () { return (React__namespace.createElement(Icon, { size: 16 },
    React__namespace.createElement("path", { d: "M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z" }))); };

var Text = function (_a) {
    var annotation = _a.annotation, childAnnotation = _a.childAnnotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    var name = annotation.name ? annotation.name.toLowerCase() : '';
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: false, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--text", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }),
            name && (React__namespace.createElement("div", { className: "rpv-core__annotation-text-icon" },
                name === 'check' && React__namespace.createElement(CheckIcon, null),
                name === 'comment' && React__namespace.createElement(CommentIcon, null),
                name === 'help' && React__namespace.createElement(HelpIcon, null),
                name === 'insert' && React__namespace.createElement(TriangleIcon, null),
                name === 'key' && React__namespace.createElement(KeyIcon, null),
                name === 'note' && React__namespace.createElement(NoteIcon, null),
                (name === 'newparagraph' || name === 'paragraph') && React__namespace.createElement(ParagraphIcon, null))),
            props.slot.children),
        childAnnotation &&
            childAnnotation.annotationType === exports.AnnotationType.Popup &&
            props.popup.opened && React__namespace.createElement(Popup, { annotation: childAnnotation, page: page, viewport: viewport }))); }));
};

var Underline = function (_a) {
    var annotation = _a.annotation, page = _a.page, viewport = _a.viewport;
    var hasPopup = annotation.hasPopup === false;
    var isRenderable = !!(annotation.hasPopup || annotation.title || annotation.contents);
    return (React__namespace.createElement(Annotation, { annotation: annotation, hasPopup: hasPopup, ignoreBorder: true, isRenderable: isRenderable, page: page, viewport: viewport }, function (props) { return (React__namespace.createElement("div", __assign({}, props.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--underline", "data-annotation-id": annotation.id, onClick: props.popup.toggleOnClick, onMouseEnter: props.popup.openOnHover, onMouseLeave: props.popup.closeOnHover }), props.slot.children)); }));
};

var AnnotationLayerBody = function (_a) {
    var annotations = _a.annotations, containerRef = _a.containerRef, doc = _a.doc, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest;
    var viewport = page.getViewport({ rotation: rotation, scale: scale });
    var clonedViewPort = viewport.clone({ dontFlip: true });
    var filterAnnotations = annotations.filter(function (annotation) { return !annotation.parentId; });
    React__namespace.useEffect(function () {
        var container = containerRef.current;
        if (!container) {
            return;
        }
        plugins.forEach(function (plugin) {
            if (plugin.onAnnotationLayerRender) {
                plugin.onAnnotationLayerRender({
                    annotations: filterAnnotations,
                    container: container,
                    pageIndex: pageIndex,
                    rotation: rotation,
                    scale: scale,
                });
            }
        });
    }, []);
    return (React__namespace.createElement(React__namespace.Fragment, null, filterAnnotations.map(function (annotation) {
        var childAnnotation = annotations.find(function (item) { return item.parentId === annotation.id; });
        switch (annotation.annotationType) {
            case exports.AnnotationType.Caret:
                return (React__namespace.createElement(Caret, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Circle:
                return (React__namespace.createElement(Circle, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.FileAttachment:
                return (React__namespace.createElement(FileAttachment, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.FreeText:
                return (React__namespace.createElement(FreeText, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Highlight:
                return (React__namespace.createElement(Highlight, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Ink:
                return (React__namespace.createElement(Ink, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Line:
                return (React__namespace.createElement(Line, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Link:
                return (React__namespace.createElement(Link, { key: annotation.id, annotation: annotation, doc: doc, page: page, viewport: clonedViewPort, onExecuteNamedAction: onExecuteNamedAction, onJumpToDest: onJumpToDest }));
            case exports.AnnotationType.Polygon:
                return (React__namespace.createElement(Polygon, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Polyline:
                return (React__namespace.createElement(Polyline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Popup:
                return (React__namespace.createElement(Popup, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Square:
                return (React__namespace.createElement(Square, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Squiggly:
                return (React__namespace.createElement(Squiggly, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Stamp:
                return (React__namespace.createElement(Stamp, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.StrikeOut:
                return (React__namespace.createElement(StrikeOut, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Text:
                return (React__namespace.createElement(Text, { key: annotation.id, annotation: annotation, childAnnotation: childAnnotation, page: page, viewport: clonedViewPort }));
            case exports.AnnotationType.Underline:
                return (React__namespace.createElement(Underline, { key: annotation.id, annotation: annotation, page: page, viewport: clonedViewPort }));
            default:
                return React__namespace.createElement(React__namespace.Fragment, { key: annotation.id });
        }
    })));
};

var AnnotationLoader = function (_a) {
    var page = _a.page, renderAnnotations = _a.renderAnnotations;
    var _b = React__namespace.useState({
        loading: true,
        annotations: [],
    }), status = _b[0], setStatus = _b[1];
    React__namespace.useEffect(function () {
        page.getAnnotations({ intent: 'display' }).then(function (result) {
            setStatus({
                loading: false,
                annotations: result,
            });
        });
    }, []);
    return status.loading ? React__namespace.createElement(React__namespace.Fragment, null) : renderAnnotations(status.annotations);
};

var AnnotationLayer = function (_a) {
    var doc = _a.doc, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest;
    var containerRef = React__namespace.useRef();
    var renderAnnotations = function (annotations) {
        return (React__namespace.createElement(AnnotationLayerBody, { annotations: annotations, containerRef: containerRef, doc: doc, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotation, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpToDest: onJumpToDest }));
    };
    return (React__namespace.createElement("div", { ref: containerRef, className: "rpv-core__annotation-layer" },
        React__namespace.createElement(AnnotationLoader, { page: page, renderAnnotations: renderAnnotations })));
};

var WithScale = function (_a) {
    var callback = _a.callback, children = _a.children, rotation = _a.rotation, scale = _a.scale;
    useIsomorphicLayoutEffect(function () {
        callback();
    }, [rotation, scale]);
    return React__namespace.createElement(React__namespace.Fragment, null, children);
};

var CanvasLayer = function (_a) {
    var height = _a.height, page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale, width = _a.width;
    var canvasRef = React__namespace.useRef();
    var renderTask = React__namespace.useRef();
    var _b = React__namespace.useState(false), rendered = _b[0], setRendered = _b[1];
    var devicePixelRatio = window.devicePixelRatio || 1;
    var renderCanvas = function () {
        setRendered(false);
        var task = renderTask.current;
        if (task) {
            task.cancel();
        }
        var canvasEle = canvasRef.current;
        plugins.forEach(function (plugin) {
            if (plugin.onCanvasLayerRender) {
                plugin.onCanvasLayerRender({
                    ele: canvasEle,
                    pageIndex: pageIndex,
                    rotation: rotation,
                    scale: scale,
                    status: exports.LayerRenderStatus.PreRender,
                });
            }
        });
        canvasEle.height = height * devicePixelRatio;
        canvasEle.width = width * devicePixelRatio;
        canvasEle.style.opacity = '0';
        var canvasContext = canvasEle.getContext('2d', {
            alpha: false,
        });
        var viewport = page.getViewport({
            rotation: rotation,
            scale: scale * devicePixelRatio,
        });
        renderTask.current = page.render({ canvasContext: canvasContext, viewport: viewport });
        renderTask.current.promise.then(function () {
            setRendered(true);
            canvasEle.style.removeProperty('opacity');
            plugins.forEach(function (plugin) {
                if (plugin.onCanvasLayerRender) {
                    plugin.onCanvasLayerRender({
                        ele: canvasEle,
                        pageIndex: pageIndex,
                        rotation: rotation,
                        scale: scale,
                        status: exports.LayerRenderStatus.DidRender,
                    });
                }
            });
        }, function () {
            setRendered(true);
        });
    };
    return (React__namespace.createElement(WithScale, { callback: renderCanvas, rotation: rotation, scale: scale },
        React__namespace.createElement("div", { className: "rpv-core__canvas-layer", style: {
                height: height + "px",
                width: width + "px",
            } },
            !rendered && (React__namespace.createElement("div", { className: "rpv-core__canvas-layer-loader" },
                React__namespace.createElement(Spinner, null))),
            React__namespace.createElement("canvas", { ref: canvasRef, style: {
                    transform: "scale(" + 1 / devicePixelRatio + ")",
                    transformOrigin: "top left",
                } }))));
};

var SvgLayer = function (_a) {
    var height = _a.height, page = _a.page, rotation = _a.rotation, scale = _a.scale, width = _a.width;
    var containerRef = React__namespace.useRef();
    var empty = function () {
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        containerEle.innerHTML = '';
    };
    var renderSvg = function () {
        var containerEle = containerRef.current;
        var viewport = page.getViewport({ rotation: rotation, scale: scale });
        page.getOperatorList().then(function (operatorList) {
            empty();
            var graphic = new PdfJsApi__namespace.SVGGraphics(page.commonObjs, page.objs);
            graphic.getSVG(operatorList, viewport).then(function (svg) {
                svg.style.height = height + "px";
                svg.style.width = width + "px";
                containerEle.appendChild(svg);
            });
        });
    };
    return (React__namespace.createElement(WithScale, { callback: renderSvg, rotation: rotation, scale: scale },
        React__namespace.createElement("div", { className: "rpv-core__svg-layer", ref: containerRef })));
};

var TextLayer = function (_a) {
    var page = _a.page, pageIndex = _a.pageIndex, plugins = _a.plugins, rotation = _a.rotation, scale = _a.scale;
    var containerRef = React__namespace.useRef();
    var renderTask = React__namespace.useRef();
    var empty = function () {
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        var spans = [].slice.call(containerEle.querySelectorAll('span.rpv-core__text-layer-text'));
        spans.forEach(function (span) { return containerEle.removeChild(span); });
        var breaks = [].slice.call(containerEle.querySelectorAll('br[role="presentation"]'));
        breaks.forEach(function (br) { return containerEle.removeChild(br); });
    };
    var renderText = function () {
        var task = renderTask.current;
        if (task) {
            task.cancel();
        }
        var containerEle = containerRef.current;
        if (!containerEle) {
            return;
        }
        var viewport = page.getViewport({ rotation: rotation, scale: scale });
        plugins.forEach(function (plugin) {
            if (plugin.onTextLayerRender) {
                plugin.onTextLayerRender({
                    ele: containerEle,
                    pageIndex: pageIndex,
                    scale: scale,
                    status: exports.LayerRenderStatus.PreRender,
                });
            }
        });
        page.getTextContent().then(function (textContent) {
            empty();
            renderTask.current = PdfJsApi__namespace.renderTextLayer({
                container: containerEle,
                textContent: textContent,
                viewport: viewport,
                enhanceTextSelection: true,
            });
            renderTask.current.promise.then(function () {
                var spans = [].slice.call(containerEle.querySelectorAll('span'));
                spans.forEach(function (span) { return span.classList.add('rpv-core__text-layer-text'); });
                plugins.forEach(function (plugin) {
                    if (plugin.onTextLayerRender) {
                        plugin.onTextLayerRender({
                            ele: containerEle,
                            pageIndex: pageIndex,
                            scale: scale,
                            status: exports.LayerRenderStatus.DidRender,
                        });
                    }
                });
            }, function () {
            });
        });
    };
    return (React__namespace.createElement(WithScale, { callback: renderText, rotation: rotation, scale: scale },
        React__namespace.createElement("div", { className: "rpv-core__text-layer", ref: containerRef })));
};

var NUMBER_OF_OVERSCAN_PAGES = 2;
var PageLayer = function (_a) {
    var currentPage = _a.currentPage, doc = _a.doc, height = _a.height, pageIndex = _a.pageIndex, plugins = _a.plugins, renderPage = _a.renderPage, rotation = _a.rotation, scale = _a.scale, width = _a.width, onExecuteNamedAction = _a.onExecuteNamedAction, onJumpToDest = _a.onJumpToDest, onPageVisibilityChanged = _a.onPageVisibilityChanged;
    var _b = React__namespace.useState({
        page: null,
        pageHeight: height,
        pageWidth: width,
        viewportRotation: 0,
    }), pageSize = _b[0], setPageSize = _b[1];
    var page = pageSize.page, pageHeight = pageSize.pageHeight, pageWidth = pageSize.pageWidth;
    var prevIsCalculated = React__namespace.useRef(false);
    var intersectionThreshold = Array(10)
        .fill(null)
        .map(function (_, i) { return i / 10; });
    var scaledWidth = pageWidth * scale;
    var scaledHeight = pageHeight * scale;
    var isVertical = Math.abs(rotation) % 180 === 0;
    var w = isVertical ? scaledWidth : scaledHeight;
    var h = isVertical ? scaledHeight : scaledWidth;
    var determinePageSize = function () {
        if (prevIsCalculated.current) {
            return;
        }
        prevIsCalculated.current = true;
        doc.getPage(pageIndex + 1).then(function (pdfPage) {
            var viewport = pdfPage.getViewport({ scale: 1 });
            setPageSize({
                page: pdfPage,
                pageHeight: viewport.height,
                pageWidth: viewport.width,
                viewportRotation: viewport.rotation,
            });
        });
    };
    var visibilityChanged = function (params) {
        onPageVisibilityChanged(pageIndex, params.isVisible ? params.ratio : -1);
        if (params.isVisible) {
            determinePageSize();
        }
    };
    var defaultPageRenderer = function (props) { return (React__namespace.createElement(React__namespace.Fragment, null,
        props.canvasLayer.children,
        props.textLayer.children,
        props.annotationLayer.children)); };
    var renderPageLayer = renderPage || defaultPageRenderer;
    var rotationNumber = (rotation + pageSize.viewportRotation) % 360;
    var containerRef = useIntersectionObserver({
        threshold: intersectionThreshold,
        onVisibilityChanged: visibilityChanged,
    });
    React__namespace.useEffect(function () {
        if (currentPage - NUMBER_OF_OVERSCAN_PAGES <= pageIndex &&
            pageIndex <= currentPage + NUMBER_OF_OVERSCAN_PAGES) {
            determinePageSize();
        }
    }, [currentPage]);
    return (React__namespace.createElement("div", { ref: containerRef, className: "rpv-core__page-layer", "data-testid": "viewer-page-layer-" + pageIndex, style: {
            height: h + "px",
            width: w + "px",
        } }, !page ? (React__namespace.createElement(Spinner, null)) : (React__namespace.createElement(React__namespace.Fragment, null,
        renderPageLayer({
            annotationLayer: {
                attrs: {},
                children: (React__namespace.createElement(AnnotationLayer, { doc: doc, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationNumber, scale: scale, onExecuteNamedAction: onExecuteNamedAction, onJumpToDest: onJumpToDest })),
            },
            canvasLayer: {
                attrs: {},
                children: (React__namespace.createElement(CanvasLayer, { height: h, page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationNumber, scale: scale, width: w })),
            },
            doc: doc,
            height: h,
            pageIndex: pageIndex,
            rotation: rotation,
            scale: scale,
            svgLayer: {
                attrs: {},
                children: (React__namespace.createElement(SvgLayer, { height: h, page: page, rotation: rotationNumber, scale: scale, width: w })),
            },
            textLayer: {
                attrs: {},
                children: (React__namespace.createElement(TextLayer, { page: page, pageIndex: pageIndex, plugins: plugins, rotation: rotationNumber, scale: scale })),
            },
            width: w,
        }),
        plugins.map(function (plugin, idx) {
            return plugin.renderPageLayer ? (React__namespace.createElement(React__namespace.Fragment, { key: idx }, plugin.renderPageLayer({
                doc: doc,
                height: h,
                pageIndex: pageIndex,
                rotation: rotation,
                scale: scale,
                width: w,
            }))) : (React__namespace.createElement(React__namespace.Fragment, { key: idx }));
        })))));
};

var getFileExt = function (url) {
    var str = url.split(/\./).pop();
    return str ? str.toLowerCase() : '';
};

var SCROLL_BAR_WIDTH = 17;
var PAGE_PADDING = 8;
var calculateScale = function (container, pageHeight, pageWidth, scale) {
    switch (scale) {
        case exports.SpecialZoomLevel.ActualSize:
            return 1;
        case exports.SpecialZoomLevel.PageFit:
            return Math.min((container.clientWidth - SCROLL_BAR_WIDTH) / pageWidth, (container.clientHeight - 2 * PAGE_PADDING) / pageHeight);
        case exports.SpecialZoomLevel.PageWidth:
            return (container.clientWidth - SCROLL_BAR_WIDTH) / pageWidth;
    }
};

var Inner = function (_a) {
    var doc = _a.doc, initialPage = _a.initialPage, pageSize = _a.pageSize, plugins = _a.plugins, renderPage = _a.renderPage, viewerState = _a.viewerState, onDocumentLoad = _a.onDocumentLoad, onOpenFile = _a.onOpenFile, onPageChange = _a.onPageChange, onZoom = _a.onZoom;
    var l10n = React__namespace.useContext(LocalizationContext);
    var containerRef = React__namespace.useRef(null);
    var pagesRef = React__namespace.useRef(null);
    var _b = React__namespace.useState(0), currentPage = _b[0], setCurrentPage = _b[1];
    var _c = React__namespace.useState(0), rotation = _c[0], setRotation = _c[1];
    var stateRef = React__namespace.useRef(viewerState);
    var _d = React__namespace.useState(pageSize.scale), scale = _d[0], setScale = _d[1];
    var numPages = doc.numPages;
    var pageWidth = pageSize.pageWidth, pageHeight = pageSize.pageHeight;
    var arr = Array(numPages).fill(null);
    var pageVisibility = arr.map(function () { return 0; });
    var pageRefs = arr.map(function () { return React__namespace.useRef(); });
    var setViewerState = function (viewerState) {
        var newState = viewerState;
        plugins.forEach(function (plugin) {
            if (plugin.onViewerStateChange) {
                newState = plugin.onViewerStateChange(newState);
            }
        });
        stateRef.current = newState;
    };
    var getPagesContainer = function () { return pagesRef.current; };
    var getPageElement = function (pageIndex) {
        if (pageIndex < 0 || pageIndex >= numPages) {
            return null;
        }
        return pageRefs[pageIndex].current;
    };
    var getViewerState = function () { return stateRef.current; };
    var jumpToDestination = function (pageIndex, bottomOffset, leftOffset, scaleTo) {
        var pagesContainer = pagesRef.current;
        var currentState = stateRef.current;
        if (!pagesContainer || !currentState) {
            return;
        }
        var newPageIndex = pageIndex + 1;
        doc.getPage(newPageIndex).then(function (page) {
            var viewport = page.getViewport({ scale: 1 });
            var top = 0;
            var bottom = bottomOffset || 0;
            var left = leftOffset || 0;
            var updateScale = currentState.scale;
            switch (scaleTo) {
                case exports.SpecialZoomLevel.PageFit:
                    top = 0;
                    left = 0;
                    zoom(exports.SpecialZoomLevel.PageFit);
                    break;
                case exports.SpecialZoomLevel.PageWidth:
                    updateScale = calculateScale(pagesContainer, pageHeight, pageWidth, exports.SpecialZoomLevel.PageWidth);
                    top = (viewport.height - bottom) * updateScale;
                    left = left * updateScale;
                    zoom(updateScale);
                    break;
                default:
                    top = (viewport.height - bottom) * currentState.scale;
                    left = left * currentState.scale;
                    break;
            }
            var targetPageEle = pageRefs[pageIndex].current;
            if (targetPageEle) {
                pagesContainer.scrollTop = targetPageEle.offsetTop + top;
                pagesContainer.scrollLeft = targetPageEle.offsetLeft + left;
            }
        });
    };
    var jumpToPage = function (pageIndex) {
        if (pageIndex < 0 || pageIndex >= numPages) {
            return;
        }
        var pagesContainer = pagesRef.current;
        var targetPage = pageRefs[pageIndex].current;
        if (pagesContainer && targetPage) {
            pagesContainer.scrollTop = targetPage.offsetTop;
            pagesContainer.scrollLeft = targetPage.offsetLeft;
        }
        setCurrentPage(pageIndex);
    };
    var openFile = function (file) {
        if (getFileExt(file.name).toLowerCase() !== 'pdf') {
            return;
        }
        new Promise(function (resolve) {
            var reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = function () {
                var bytes = new Uint8Array(reader.result);
                resolve(bytes);
            };
        }).then(function (data) {
            onOpenFile(file.name, data);
        });
    };
    var rotate = function (updateRotation) {
        setRotation(updateRotation);
        setViewerState({
            file: viewerState.file,
            pageIndex: currentPage,
            pageHeight: pageHeight,
            pageWidth: pageWidth,
            rotation: updateRotation,
            scale: scale,
        });
    };
    var zoom = function (newScale) {
        var pagesEle = pagesRef.current;
        var updateScale = pagesEle
            ? typeof newScale === 'string'
                ? calculateScale(pagesEle, pageHeight, pageWidth, newScale)
                : newScale
            : 1;
        setScale(updateScale);
        onZoom({ doc: doc, scale: updateScale });
    };
    React__namespace.useEffect(function () {
        var pagesEle = pagesRef.current;
        var currentState = stateRef.current;
        if (!pagesEle || !currentState) {
            return;
        }
        pagesEle.scrollTop = (pagesEle.scrollTop * scale) / currentState.scale;
        pagesEle.scrollLeft = (pagesEle.scrollLeft * scale) / currentState.scale;
        setViewerState({
            file: viewerState.file,
            pageIndex: currentState.pageIndex,
            pageHeight: pageHeight,
            pageWidth: pageWidth,
            rotation: rotation,
            scale: scale,
        });
    }, [scale]);
    var getPluginMethods = function () { return ({
        getPageElement: getPageElement,
        getPagesContainer: getPagesContainer,
        getViewerState: getViewerState,
        jumpToDestination: jumpToDestination,
        jumpToPage: jumpToPage,
        openFile: openFile,
        rotate: rotate,
        setViewerState: setViewerState,
        zoom: zoom,
    }); };
    React__namespace.useEffect(function () {
        var pluginMethods = getPluginMethods();
        plugins.forEach(function (plugin) {
            if (plugin.install) {
                plugin.install(pluginMethods);
            }
        });
        return function () {
            plugins.forEach(function (plugin) {
                if (plugin.uninstall) {
                    plugin.uninstall(pluginMethods);
                }
            });
        };
    }, []);
    React__namespace.useEffect(function () {
        onDocumentLoad({ doc: doc });
        plugins.forEach(function (plugin) {
            plugin.onDocumentLoad && plugin.onDocumentLoad({ doc: doc });
        });
        if (initialPage) {
            jumpToPage(initialPage);
        }
    }, []);
    React__namespace.useEffect(function () {
        onPageChange({ currentPage: currentPage, doc: doc });
        setViewerState({
            file: viewerState.file,
            pageIndex: currentPage,
            pageHeight: pageHeight,
            pageWidth: pageWidth,
            rotation: rotation,
            scale: scale,
        });
    }, [currentPage]);
    var pageVisibilityChanged = function (pageIndex, ratio) {
        pageVisibility[pageIndex] = ratio;
        var maxRatioPage = pageVisibility.reduce(function (maxIndex, item, index, array) {
            return item > array[maxIndex] ? index : maxIndex;
        }, 0);
        setCurrentPage(maxRatioPage);
    };
    var executeNamedAction = function (action) {
        var previousPage = currentPage - 1;
        var nextPage = currentPage + 1;
        switch (action) {
            case 'FirstPage':
                jumpToPage(0);
                break;
            case 'LastPage':
                jumpToPage(numPages - 1);
                break;
            case 'NextPage':
                nextPage < numPages && jumpToPage(nextPage);
                break;
            case 'PrevPage':
                previousPage >= 0 && jumpToPage(previousPage);
                break;
        }
    };
    var pageLabel = (l10n && l10n.core ? l10n.core.pageLabel : 'Page {{pageIndex}}');
    var renderViewer = function () {
        var slot = {
            attrs: {
                ref: containerRef,
                style: {
                    height: '100%',
                },
            },
            children: React__namespace.createElement(React__namespace.Fragment, null),
            subSlot: {
                attrs: {
                    ref: pagesRef,
                    style: {
                        height: '100%',
                        overflow: 'auto',
                        position: 'relative',
                    },
                },
                children: (React__namespace.createElement(React__namespace.Fragment, null, Array(numPages)
                    .fill(0)
                    .map(function (_, index) {
                    return (React__namespace.createElement("div", { "aria-label": pageLabel.replace('{{pageIndex}}', "" + (index + 1)), className: "rpv-core__inner-page", key: "pagelayer-" + index, ref: function (ref) {
                            pageRefs[index].current = ref;
                        }, role: "region" },
                        React__namespace.createElement(PageLayer, { currentPage: currentPage, doc: doc, height: pageHeight, pageIndex: index, plugins: plugins, renderPage: renderPage, rotation: rotation, scale: scale, width: pageWidth, onExecuteNamedAction: executeNamedAction, onJumpToDest: jumpToDestination, onPageVisibilityChanged: pageVisibilityChanged })));
                }))),
            },
        };
        plugins.forEach(function (plugin) {
            if (plugin.renderViewer) {
                slot = plugin.renderViewer({
                    containerRef: containerRef,
                    doc: doc,
                    pageHeight: pageHeight,
                    pageWidth: pageWidth,
                    rotation: rotation,
                    slot: slot,
                    jumpToPage: jumpToPage,
                    openFile: openFile,
                    rotate: rotate,
                    zoom: zoom,
                });
            }
        });
        return slot;
    };
    var renderSlot = function (slot) { return (React__namespace.createElement("div", __assign({}, slot.attrs, { style: slot.attrs && slot.attrs.style ? slot.attrs.style : {} }),
        slot.children,
        slot.subSlot && renderSlot(slot.subSlot))); };
    return renderSlot(renderViewer());
};

var LEVELS = [
    0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9, 2.1, 2.4, 2.7, 3.0, 3.3, 3.7, 4.1, 4.6,
    5.1, 5.7, 6.3, 7.0, 7.7, 8.5, 9.4, 10,
];
var decrease = function (currentLevel) {
    var found = LEVELS.findIndex(function (item) { return item >= currentLevel; });
    return found === -1 || found === 0 ? currentLevel : LEVELS[found - 1];
};

var PageSizeCalculator = function (_a) {
    var defaultScale = _a.defaultScale, doc = _a.doc, render = _a.render;
    var pagesRef = React__namespace.useRef(null);
    var _b = React__namespace.useState({
        pageHeight: 0,
        pageWidth: 0,
        scale: 1,
    }), pageSize = _b[0], setPageSize = _b[1];
    React__namespace.useEffect(function () {
        doc.getPage(1).then(function (pdfPage) {
            var viewport = pdfPage.getViewport({ scale: 1 });
            var w = viewport.width;
            var h = viewport.height;
            var pagesEle = pagesRef.current;
            if (!pagesEle) {
                return;
            }
            var scaled = (pagesEle.clientWidth - 2 * 50) / w;
            var scale = defaultScale
                ? typeof defaultScale === 'string'
                    ? calculateScale(pagesEle, h, w, defaultScale)
                    : defaultScale
                : decrease(scaled);
            setPageSize({
                pageHeight: h,
                pageWidth: w,
                scale: scale,
            });
        });
    }, [doc]);
    var pageWidth = pageSize.pageWidth;
    return pageWidth === 0 ? (React__namespace.createElement("div", { className: "rpv-core__page-size-calculator", ref: pagesRef },
        React__namespace.createElement(Spinner, null))) : (render(pageSize));
};

var useIsMounted = function () {
    var isMountedRef = React__namespace.useRef(false);
    React__namespace.useEffect(function () {
        isMountedRef.current = true;
        return function () {
            isMountedRef.current = false;
        };
    }, []);
    return isMountedRef;
};

var LoadingStatus = (function () {
    function LoadingStatus() {
    }
    return LoadingStatus;
}());

var AskForPasswordState = (function (_super) {
    __extends(AskForPasswordState, _super);
    function AskForPasswordState(verifyPasswordFn) {
        var _this = _super.call(this) || this;
        _this.verifyPasswordFn = verifyPasswordFn;
        return _this;
    }
    return AskForPasswordState;
}(LoadingStatus));

var AskingPassword = function (_a) {
    var verifyPasswordFn = _a.verifyPasswordFn;
    var l10n = React__namespace.useContext(LocalizationContext);
    var _b = React__namespace.useState(''), password = _b[0], setPassword = _b[1];
    var submit = function () { return verifyPasswordFn(password); };
    return (React__namespace.createElement("div", { className: "rpv-core__asking-password-wrapper" },
        React__namespace.createElement("div", { className: "rpv-core__asking-password" },
            React__namespace.createElement("div", { className: "rpv-core__asking-password-message" },
                l10n.core.askingPassword.requirePasswordToOpen,
                ":"),
            React__namespace.createElement("div", { className: "rpv-core__asking-password-body" },
                React__namespace.createElement("div", { className: "rpv-core__asking-password-input" },
                    React__namespace.createElement(TextBox, { type: "password", value: password, onChange: setPassword })),
                React__namespace.createElement(PrimaryButton, { onClick: submit }, l10n.core.askingPassword.submit)))));
};

var CompletedState = (function (_super) {
    __extends(CompletedState, _super);
    function CompletedState(doc) {
        var _this = _super.call(this) || this;
        _this.doc = doc;
        return _this;
    }
    return CompletedState;
}(LoadingStatus));

var FailureState = (function (_super) {
    __extends(FailureState, _super);
    function FailureState(error) {
        var _this = _super.call(this) || this;
        _this.error = error;
        return _this;
    }
    return FailureState;
}(LoadingStatus));

var LoadingState = (function (_super) {
    __extends(LoadingState, _super);
    function LoadingState(percentages) {
        var _this = _super.call(this) || this;
        _this.percentages = percentages;
        return _this;
    }
    return LoadingState;
}(LoadingStatus));

var WrongPassword = function (_a) {
    var verifyPasswordFn = _a.verifyPasswordFn;
    var l10n = React__namespace.useContext(LocalizationContext);
    var _b = React__namespace.useState(''), password = _b[0], setPassword = _b[1];
    var submit = function () { return verifyPasswordFn(password); };
    return (React__namespace.createElement("div", { className: "rpv-core__asking-password-wrapper" },
        React__namespace.createElement("div", { className: "rpv-core__asking-password" },
            React__namespace.createElement("div", { className: "rpv-core__asking-password-message" },
                l10n.core.wrongPassword.tryAgain,
                ":"),
            React__namespace.createElement("div", { className: "rpv-core__asking-password-body" },
                React__namespace.createElement("div", { className: "rpv-core__asking-password-input" },
                    React__namespace.createElement(TextBox, { type: "password", value: password, onChange: setPassword })),
                React__namespace.createElement("button", { className: "rpv-core__asking-password-button", onClick: submit }, l10n.core.wrongPassword.submit)))));
};

var WrongPasswordState = (function (_super) {
    __extends(WrongPasswordState, _super);
    function WrongPasswordState(verifyPasswordFn) {
        var _this = _super.call(this) || this;
        _this.verifyPasswordFn = verifyPasswordFn;
        return _this;
    }
    return WrongPasswordState;
}(LoadingStatus));

var DocumentLoader = function (_a) {
    var characterMap = _a.characterMap, file = _a.file, httpHeaders = _a.httpHeaders, render = _a.render, renderError = _a.renderError, renderLoader = _a.renderLoader, transformGetDocumentParams = _a.transformGetDocumentParams, withCredentials = _a.withCredentials;
    var _b = React__namespace.useState(new LoadingState(0)), status = _b[0], setStatus = _b[1];
    var _c = React__namespace.useState(0), percentages = _c[0], setPercentages = _c[1];
    var _d = React__namespace.useState(null), loadedDocument = _d[0], setLoadedDocument = _d[1];
    var isMounted = useIsMounted();
    React__namespace.useEffect(function () {
        setStatus(new LoadingState(0));
        var worker = new PdfJsApi__namespace.PDFWorker({ name: "PDFWorker_" + Date.now() });
        var params = Object.assign({
            httpHeaders: httpHeaders,
            withCredentials: withCredentials,
            worker: worker,
        }, 'string' === typeof file ? { url: file } : { data: file }, characterMap
            ? {
                cMapUrl: characterMap.url,
                cMapPacked: characterMap.isCompressed,
            }
            : {});
        var transformParams = transformGetDocumentParams ? transformGetDocumentParams(params) : params;
        var loadingTask = PdfJsApi__namespace.getDocument(transformParams);
        loadingTask.onPassword = function (verifyPassword, reason) {
            switch (reason) {
                case PdfJsApi__namespace.PasswordResponses.NEED_PASSWORD:
                    isMounted.current && setStatus(new AskForPasswordState(verifyPassword));
                    break;
                case PdfJsApi__namespace.PasswordResponses.INCORRECT_PASSWORD:
                    isMounted.current && setStatus(new WrongPasswordState(verifyPassword));
                    break;
            }
        };
        loadingTask.onProgress = function (progress) {
            progress.total > 0
                ?
                    isMounted.current && setPercentages(Math.min(100, (100 * progress.loaded) / progress.total))
                : isMounted.current && setPercentages(100);
        };
        loadingTask.promise.then(function (doc) { return isMounted.current && setLoadedDocument(doc); }, function (err) {
            return isMounted.current &&
                !worker.destroyed &&
                setStatus(new FailureState({
                    message: err.message || 'Cannot load document',
                    name: err.name,
                }));
        });
        return function () {
            loadingTask.destroy();
            worker.destroy();
        };
    }, [file]);
    React__namespace.useEffect(function () {
        percentages === 100 && loadedDocument
            ? isMounted.current && setStatus(new CompletedState(loadedDocument))
            : isMounted.current && setStatus(new LoadingState(percentages));
    }, [percentages, loadedDocument]);
    switch (true) {
        case status instanceof AskForPasswordState:
            return React__namespace.createElement(AskingPassword, { verifyPasswordFn: status.verifyPasswordFn });
        case status instanceof WrongPasswordState:
            return React__namespace.createElement(WrongPassword, { verifyPasswordFn: status.verifyPasswordFn });
        case status instanceof CompletedState:
            return render(status.doc);
        case status instanceof FailureState:
            return renderError ? (renderError(status.error)) : (React__namespace.createElement("div", { className: "rpv-core__doc-error" },
                React__namespace.createElement("div", { className: "rpv-core__doc-error-text" }, status.error.message)));
        case status instanceof LoadingState:
            return (React__namespace.createElement("div", { className: "rpv-core__doc-loading" }, renderLoader ? renderLoader(status.percentages) : React__namespace.createElement(Spinner, null)));
        default:
            return (React__namespace.createElement("div", { className: "rpv-core__doc-loading" },
                React__namespace.createElement(Spinner, null)));
    }
};

var isSameUrl = function (a, b) {
    var typeA = typeof a;
    var typeB = typeof b;
    if (typeA === 'string' && typeB === 'string' && a === b) {
        return true;
    }
    if (typeA === 'object' && typeB === 'object') {
        return a.length === b.length && a.every(function (v, i) { return v === b[i]; });
    }
    return false;
};

var Viewer = function (_a) {
    var characterMap = _a.characterMap, defaultScale = _a.defaultScale, fileUrl = _a.fileUrl, _b = _a.httpHeaders, httpHeaders = _b === void 0 ? {} : _b, _c = _a.initialPage, initialPage = _c === void 0 ? 0 : _c, localization = _a.localization, _d = _a.plugins, plugins = _d === void 0 ? [] : _d, renderError = _a.renderError, renderPage = _a.renderPage, renderLoader = _a.renderLoader, transformGetDocumentParams = _a.transformGetDocumentParams, _e = _a.theme, theme = _e === void 0 ? 'light' : _e, _f = _a.withCredentials, withCredentials = _f === void 0 ? false : _f, _g = _a.onDocumentLoad, onDocumentLoad = _g === void 0 ? function () {
    } : _g, _h = _a.onPageChange, onPageChange = _h === void 0 ? function () {
    } : _h, _j = _a.onSwitchTheme, onSwitchTheme = _j === void 0 ? function () {
    } : _j, _k = _a.onZoom, onZoom = _k === void 0 ? function () {
    } : _k;
    var _l = React__namespace.useState({
        data: fileUrl,
        name: typeof fileUrl === 'string' ? fileUrl : '',
        shouldLoad: false,
    }), file = _l[0], setFile = _l[1];
    var openFile = function (fileName, data) {
        setFile({
            data: data,
            name: fileName,
            shouldLoad: true,
        });
    };
    var _m = React__namespace.useState(false), visible = _m[0], setVisible = _m[1];
    var prevFile = usePrevious(file);
    React__namespace.useEffect(function () {
        if (!isSameUrl(prevFile.data, fileUrl)) {
            setFile({
                data: fileUrl,
                name: typeof fileUrl === 'string' ? fileUrl : '',
                shouldLoad: visible,
            });
        }
    }, [fileUrl, visible]);
    var visibilityChanged = function (params) {
        setVisible(params.isVisible);
        if (params.isVisible) {
            setFile(function (currentFile) { return Object.assign({}, currentFile, { shouldLoad: true }); });
        }
    };
    var containerRef = useIntersectionObserver({
        onVisibilityChanged: visibilityChanged,
    });
    return (React__namespace.createElement(ThemeProvider, { theme: theme, onSwitchTheme: onSwitchTheme },
        React__namespace.createElement(LocalizationProvider, { localization: localization }, function (_) {
            var themeContext = React__namespace.useContext(ThemeContext);
            return (React__namespace.createElement("div", { ref: containerRef, className: "rpv-core__viewer rpv-core__viewer--" + themeContext.currentTheme, "data-testid": "viewer", style: {
                    height: '100%',
                    width: '100%',
                } }, file.shouldLoad && (React__namespace.createElement(DocumentLoader, { characterMap: characterMap, file: file.data, httpHeaders: httpHeaders, render: function (doc) { return (React__namespace.createElement(PageSizeCalculator, { defaultScale: defaultScale, doc: doc, render: function (ps) { return (React__namespace.createElement(Inner, { doc: doc, initialPage: initialPage, pageSize: ps, plugins: plugins, renderPage: renderPage, viewerState: {
                            file: file,
                            pageIndex: initialPage,
                            pageHeight: ps.pageHeight,
                            pageWidth: ps.pageWidth,
                            rotation: 0,
                            scale: ps.scale,
                        }, onDocumentLoad: onDocumentLoad, onOpenFile: openFile, onPageChange: onPageChange, onZoom: onZoom })); } })); }, renderError: renderError, renderLoader: renderLoader, transformGetDocumentParams: transformGetDocumentParams, withCredentials: withCredentials }))));
        })));
};

var Worker = function (_a) {
    var children = _a.children, workerUrl = _a.workerUrl;
    PdfJsApi__namespace.GlobalWorkerOptions.workerSrc = workerUrl;
    return React__namespace.createElement(React__namespace.Fragment, null, children);
};

var isMac = function () { return (typeof window !== 'undefined' ? /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) : false); };

exports.Button = Button;
exports.Icon = Icon;
exports.LocalizationContext = LocalizationContext;
exports.LocalizationProvider = LocalizationProvider;
exports.Menu = Menu;
exports.MenuDivider = MenuDivider;
exports.MenuItem = MenuItem;
exports.MinimalButton = MinimalButton;
exports.Modal = Modal;
exports.Popover = Popover;
exports.PrimaryButton = PrimaryButton;
exports.ProgressBar = ProgressBar;
exports.Separator = Separator;
exports.Spinner = Spinner;
exports.TextBox = TextBox;
exports.ThemeContext = ThemeContext;
exports.ThemeProvider = ThemeProvider;
exports.Tooltip = Tooltip;
exports.Viewer = Viewer;
exports.Worker = Worker;
exports.classNames = classNames;
exports.createStore = createStore;
exports.getDestination = getDestination;
exports.isMac = isMac;
exports.useIntersectionObserver = useIntersectionObserver;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;

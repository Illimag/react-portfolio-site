import { Component, createElement, useRef, useState, useCallback, useEffect } from 'react';

const ObserverMap = new Map();
const RootIds = new Map();
let consecutiveRootId = 0;
/**
 * Generate a unique ID for the root element
 * @param root
 */

function getRootId(root) {
  if (!root) return '';
  if (RootIds.has(root)) return RootIds.get(root);
  consecutiveRootId += 1;
  RootIds.set(root, consecutiveRootId.toString());
  return RootIds.get(root);
}
/**
 * Convert the options to a string Id, based on the values.
 * Ensures we can reuse the same observer for, when observer elements with the same options.
 * @param options
 */


function optionsToId(options) {
  return Object.keys(options).sort().map(key => {
    return `${key}_${key === 'root' ? getRootId(options.root) : options[key]}`;
  }).join('|');
}

function createObserver(options) {
  // Create a unique ID for this observer instance, based on the root, root margin and threshold.
  let id = optionsToId(options);
  let instance = ObserverMap.get(id);

  if (!instance) {
    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.
    const elements = new Map();
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.
        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0
        const inView = entry.isIntersecting && observer.thresholds.some(threshold => entry.intersectionRatio >= threshold); // @ts-ignore support IntersectionObserver v2

        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {
          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.
          // @ts-ignore
          entry.isVisible = inView;
        }

        elements.get(entry.target)?.forEach(callback => {
          callback(inView, entry);
        });
      });
    }, options);
    instance = {
      id,
      observer,
      elements
    };
    ObserverMap.set(id, instance);
  }

  return instance;
}

function observe(element, callback, options = {}) {
  if (!element) return () => {}; // An observer with the same options can be reused, so lets use this fact

  const {
    id,
    observer,
    elements
  } = createObserver(options); // Register the callback listener for this element

  let callbacks = elements.get(element) || [];

  if (!elements.has(element)) {
    elements.set(element, callbacks);
  }

  callbacks.push(callback);
  observer.observe(element);
  return function unobserve() {
    // Remove the callback from the callback list
    callbacks.splice(callbacks.indexOf(callback), 1);

    if (callbacks.length === 0) {
      // No more callback exists for element, so destroy it
      elements.delete(element);
      observer.unobserve(element);
    }

    if (elements.size === 0) {
      // No more elements are being observer by this instance, so destroy it
      observer.disconnect();
      ObserverMap.delete(id);
    }
  };
}

function isPlainChildren(props) {
  return typeof props.children !== 'function';
}
/**
 * Monitors scroll, and triggers the children function with updated props
 */


class InView extends Component {
  constructor() {
    super(...arguments);
    this.state = {
      inView: false,
      entry: undefined
    };
    this.node = null;
    this._unobserveCb = null;

    this.handleNode = node => {
      if (this.node) {
        this.unobserve();

        if (!node && !this.props.triggerOnce && !this.props.skip) {
          this.setState({
            inView: false,
            entry: undefined
          });
        }
      }

      this.node = node ? node : null;
      this.observeNode();
    };

    this.handleChange = (inView, entry) => {
      // Only trigger a state update if inView has changed.
      // This prevents an unnecessary extra state update during mount, when the element stats outside the viewport
      if (inView !== this.state.inView || inView) {
        this.setState({
          inView,
          entry
        });
      }

      if (this.props.onChange) {
        // If the user is actively listening for onChange, always trigger it
        this.props.onChange(inView, entry);
      }
    };
  }

  componentDidUpdate(prevProps, prevState) {
    // If a IntersectionObserver option changed, reinit the observer
    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {
      this.unobserve();
      this.observeNode();
    }

    if (prevState.inView !== this.state.inView) {
      if (this.state.inView && this.props.triggerOnce) {
        this.unobserve();
        this.node = null;
      }
    }
  }

  componentWillUnmount() {
    if (this.node) {
      this.unobserve();
      this.node = null;
    }
  }

  observeNode() {
    if (!this.node || this.props.skip) return;
    const {
      threshold,
      root,
      rootMargin,
      trackVisibility,
      delay
    } = this.props;
    this._unobserveCb = observe(this.node, this.handleChange, {
      threshold,
      root,
      rootMargin,
      // @ts-ignore
      trackVisibility,
      // @ts-ignore
      delay
    });
  }

  unobserve() {
    if (this._unobserveCb) {
      this._unobserveCb();

      this._unobserveCb = null;
    }
  }

  render() {
    const {
      inView,
      entry
    } = this.state;

    if (!isPlainChildren(this.props)) {
      return this.props.children({
        inView,
        entry,
        ref: this.handleNode
      });
    }

    const {
      children,
      as,
      tag,
      triggerOnce,
      threshold,
      root,
      rootMargin,
      onChange,
      skip,
      trackVisibility,
      delay,
      ...props
    } = this.props;
    return /*#__PURE__*/createElement(as || tag || 'div', {
      ref: this.handleNode,
      ...props
    }, children);
  }

}
InView.displayName = 'InView';
InView.defaultProps = {
  threshold: 0,
  triggerOnce: false
};

/* eslint-disable react-hooks/exhaustive-deps */
const initialState = {
  inView: false,
  entry: undefined
};
function useInView(options = {}) {
  const unobserve = useRef();
  const [state, setState] = useState(initialState);
  const setRef = useCallback(node => {
    if (unobserve.current !== undefined) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (options.skip) {
      return;
    }

    if (node) {
      unobserve.current = observe(node, (inView, entry) => {
        setState({
          inView,
          entry
        });

        if (entry.isIntersecting && options.triggerOnce && unobserve.current) {
          // If it should only trigger once, unobserve the element after it's inView
          unobserve.current();
          unobserve.current = undefined;
        }
      }, options);
    }
  }, [options.threshold, options.root, options.rootMargin, options.triggerOnce, options.skip, options.trackVisibility, options.delay]);
  useEffect(() => {
    if (!unobserve.current && !options.triggerOnce && !options.skip) {
      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)
      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView
      setState(initialState);
    }
  });
  const result = [setRef, state.inView, state.entry]; // Support object destructuring, by adding the specific values.

  result.ref = result[0];
  result.inView = result[1];
  result.entry = result[2];
  return result;
}

export default InView;
export { InView, useInView };
//# sourceMappingURL=react-intersection-observer.esm.js.map

{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport * as React from 'react';\nimport styled, { css } from '../../utils/styled';\nimport { remCalc } from '../../utils/remCalc';\nimport { InteractiveSurface } from '../InteractiveSurface';\nimport { Icon } from '../Icon';\nimport { distance } from '../../distance';\nimport { getFontStyle } from '../../textStyles';\nconst shiftThreshold = 0.3;\nconst animationDuration = '0.3s';\nconst animationFunction = 'ease-in-out';\nconst RootContainer = styled.div`\n  outline: none;\n`;\nconst DefaultBulletsContainer = styled.div`\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n`;\nconst ActiveBullet = css`\n  background-color: rgba(116, 118, 120, 1);\n`;\nconst DefaultBullet = styled.div`\n  height: ${remCalc('12px')};\n  width: ${remCalc('12px')};\n  background-color: rgba(224, 225, 221, 1);\n  border-radius: 50%;\n  display: inline-block;\n  cursor: pointer;\n  margin: ${distance.xsmall};\n  ${props => props.active ? ActiveBullet : ''};\n`;\nconst PageItem = styled.div`\n  min-width: 100%;\n`;\nconst PagesContainer = styled.div`\n  box-sizing: border-box;\n  display: flex;\n  position: relative;\n  left: ${props => -props.selectedIndex * 100}%;\n  transition: left ${animationDuration} ${animationFunction};\n`;\nconst Mask = styled.div`\n  position: relative;\n  box-sizing: border-box;\n  overflow: hidden;\n`;\nconst Arrow = styled.button`\n  ${getFontStyle({\n  size: 'medium'\n})}\n\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  background-color: transparent;\n  padding: 0;\n  border: none;\n  align-self: start;\n  cursor: pointer;\n  > i {\n    vertical-align: middle;\n  }\n`;\nconst ArrowLeft = styled(Arrow)`\n  left: 8px;\n`;\nconst ArrowRight = styled(Arrow)`\n  right: 8px;\n`;\n\nfunction calcNextPage(currentPage, totalPages, infinite = false) {\n  const maxIndex = totalPages - 1;\n  const nextPage = currentPage + 1;\n  return infinite && nextPage > maxIndex ? 0 : Math.min(nextPage, maxIndex);\n}\n\nfunction calcPrevPage(currentPage, totalPages, infinite = false) {\n  const prevPage = currentPage - 1;\n  const maxIndex = totalPages - 1;\n  return infinite && prevPage < 0 ? maxIndex : Math.max(prevPage, 0);\n}\n\nfunction calcLeftShiftPercent(selectedIndex) {\n  return selectedIndex * -100;\n}\n\nconst defaultAutoPlayTime = 3000;\n/**\n * The Carousel component displays a toggling list of content. Page can be changed using bullet\n * controls or swiping gestures.\n */\n\nexport class Carousel extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.selects = [];\n\n    this.resume = () => {\n      if (!this.autoPlayTimeout) {\n        this.tryToPlay();\n      }\n    };\n\n    this.dragTile = e => {\n      const {\n        controlled,\n        selectedIndex,\n        dragStatus\n      } = this.state;\n      const shift = dragStatus.start ? e.x - dragStatus.start.x : 0;\n\n      if (controlled) {\n        e.release();\n      }\n\n      if (this.pagesContainer) {\n        if (e.active) {\n          if (!dragStatus.isDragging) {\n            this.setState({\n              dragStatus: {\n                isDragging: true,\n                start: {\n                  x: e.x,\n                  y: e.y\n                }\n              }\n            });\n            this.setDragStyle(this.pagesContainer);\n          }\n\n          this.pagesContainer.style.left = `${calcLeftShiftPercent(selectedIndex) + shift * 100}%`;\n        } else {\n          this.setState({\n            dragStatus: {\n              isDragging: false,\n              start: undefined\n            }\n          });\n          this.resetInitialStyle(this.pagesContainer);\n          this.checkPageChange(shift);\n        }\n      }\n    };\n\n    this.swipeLeft = () => {\n      this.swipe(-1, true);\n    };\n\n    this.swipeRight = () => {\n      this.swipe(1, true);\n    };\n\n    this.swipeRightAuto = () => {\n      this.swipe(1, false);\n    };\n\n    this.handleKeyDown = e => {\n      const {\n        children,\n        infinite\n      } = this.props;\n      const {\n        selectedIndex\n      } = this.state;\n      const childrenCount = React.Children.count(children);\n      let nextIndex = selectedIndex;\n\n      switch (e.keyCode) {\n        case 37\n        /* left */\n        :\n          nextIndex = calcPrevPage(selectedIndex, childrenCount, infinite);\n          break;\n\n        case 39\n        /* right */\n        :\n          nextIndex = calcNextPage(selectedIndex, childrenCount, infinite);\n          break;\n\n        case 35\n        /* end */\n        :\n          nextIndex = childrenCount - 1;\n          break;\n\n        case 36\n        /* home */\n        :\n          nextIndex = 0;\n          break;\n\n        default:\n          return;\n      }\n\n      this.changePage(nextIndex);\n    };\n\n    this.state = {\n      selectedIndex: props.selectedIndex || props.defaultIndex || 0,\n      controlled: props.selectedIndex !== undefined,\n      dragStatus: {\n        isDragging: false\n      }\n    };\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    const {\n      selectedIndex\n    } = nextProps;\n    const {\n      controlled\n    } = this.state;\n\n    if (controlled && typeof selectedIndex === 'number') {\n      this.setState({\n        selectedIndex\n      });\n    }\n  }\n\n  componentDidMount() {\n    this.tryToPlay();\n  }\n\n  componentWillUnmount() {\n    this.stop();\n  }\n\n  tryToPlay() {\n    this.stop();\n    const {\n      autoplay\n    } = this.props;\n\n    if (autoplay) {\n      this.play(typeof autoplay === 'number' ? autoplay : defaultAutoPlayTime);\n    }\n  }\n\n  play(time) {\n    this.autoPlayTimeout = setInterval(this.swipeRightAuto, time);\n  }\n\n  stop() {\n    this.autoPlayTimeout = clearInterval(this.autoPlayTimeout);\n  }\n\n  changePage(target, manual = true) {\n    const {\n      onPageChange,\n      onStop,\n      children\n    } = this.props;\n    const childrenCount = React.Children.count(children);\n    const {\n      controlled,\n      selectedIndex\n    } = this.state;\n    const shouldStop = target >= childrenCount || target < 0;\n\n    if (manual || shouldStop) {\n      if (this.autoPlayTimeout) {\n        this.stop();\n\n        if (typeof onStop === 'function') {\n          onStop({\n            reason: manual ? 'manual' : 'ended',\n            resume: this.resume\n          });\n        }\n      }\n    }\n\n    if (!shouldStop) {\n      if (typeof onPageChange === 'function') {\n        onPageChange({\n          previousIndex: selectedIndex,\n          selectedIndex: target\n        });\n      }\n\n      if (!controlled) {\n        this.setState(() => ({\n          selectedIndex: target\n        }));\n      }\n    }\n  }\n\n  checkPageChange(shift) {\n    const {\n      selectedIndex\n    } = this.state;\n\n    if (shift <= -shiftThreshold) {\n      const nextIndex = calcNextPage(selectedIndex, React.Children.count(this.props.children), this.props.infinite);\n      this.changePage(nextIndex);\n    } else if (shift >= shiftThreshold) {\n      const prevIndex = calcPrevPage(selectedIndex, React.Children.count(this.props.children), this.props.infinite);\n      this.changePage(prevIndex);\n    }\n  }\n\n  setDragStyle(node) {\n    const style = node.style;\n    style.transitionProperty = 'unset';\n    style.transitionDuration = 'unset';\n    style.transitionTimingFunction = 'unset';\n  }\n\n  resetInitialStyle(node) {\n    const style = node.style; // tslint:disable-next-line\n\n    style.left = null;\n    style.transitionProperty = 'left';\n    style.transitionDuration = animationDuration;\n    style.transitionTimingFunction = animationFunction;\n  }\n\n  swipe(direction, manual) {\n    const {\n      selectedIndex\n    } = this.state;\n    const {\n      children,\n      infinite\n    } = this.props;\n    const childrenCount = React.Children.count(children);\n    let nextIndex = selectedIndex;\n\n    if (direction === 1) {\n      nextIndex = calcNextPage(selectedIndex, childrenCount, infinite);\n    } else if (direction === -1) {\n      nextIndex = calcPrevPage(selectedIndex, childrenCount, infinite);\n    }\n\n    this.changePage(nextIndex, manual);\n  }\n\n  render() {\n    const {\n      selectedIndex\n    } = this.state;\n\n    const _a = this.props,\n          {\n      children,\n      theme,\n      selectedIndex: _0,\n      defaultIndex: _1,\n      onPageChange: _2,\n      bulletsContainer: CustomBulletsContainer,\n      bullet: CustomBullet,\n      arrows = false,\n      infinite = false,\n      opaque = false\n    } = _a,\n          props = __rest(_a, [\"children\", \"theme\", \"selectedIndex\", \"defaultIndex\", \"onPageChange\", \"bulletsContainer\", \"bullet\", \"arrows\", \"infinite\", \"opaque\"]);\n\n    const childrenCount = React.Children.count(children);\n    const bullets = [];\n    const items = [];\n    const selects = this.selects;\n    const BulletsContainer = CustomBulletsContainer || DefaultBulletsContainer;\n    const Bullet = CustomBullet || DefaultBullet;\n    React.Children.forEach(children, (element, index) => {\n      if (element && React.isValidElement(element)) {\n        const active = index === selectedIndex;\n\n        if (selects[index] === undefined) {\n          selects[index] = () => this.changePage(index);\n        }\n\n        bullets.push(React.createElement(Bullet, {\n          theme: theme,\n          key: `bullet-${index}`,\n          active: active,\n          index: index,\n          onClick: selects[index]\n        }));\n        items.push(React.createElement(PageItem, {\n          key: `item-${index}`\n        }, element));\n      }\n    });\n    const disableLeft = !infinite && selectedIndex < 1;\n    const disableRight = !infinite && selectedIndex > childrenCount - 2;\n    return React.createElement(RootContainer, Object.assign({}, props, {\n      onKeyDown: this.handleKeyDown,\n      tabIndex: 0\n    }), React.createElement(Mask, null, React.createElement(InteractiveSurface, {\n      theme: theme,\n      onChange: this.dragTile,\n      opaque: opaque\n    }, React.createElement(PagesContainer, {\n      ref: node => this.pagesContainer = node,\n      selectedIndex: selectedIndex\n    }, items)), arrows && React.createElement(\"div\", null, React.createElement(ArrowLeft, {\n      onClick: this.swipeLeft,\n      disabled: disableLeft,\n      type: \"button\"\n    }, React.createElement(Icon, {\n      name: \"KeyboardArrowLeft\",\n      size: 2\n    })), React.createElement(ArrowRight, {\n      onClick: this.swipeRight,\n      disabled: disableRight,\n      type: \"button\"\n    }, React.createElement(Icon, {\n      name: \"KeyboardArrowRight\",\n      size: 2\n    })))), React.createElement(BulletsContainer, null, bullets));\n  }\n\n}\nCarousel.inner = {\n  get PageItem() {\n    return PageItem;\n  },\n\n  get RootContainer() {\n    return RootContainer;\n  },\n\n  get Mask() {\n    return Mask;\n  },\n\n  get InteractiveSurface() {\n    return InteractiveSurface;\n  },\n\n  get PagesContainer() {\n    return PagesContainer;\n  },\n\n  get ArrowLeft() {\n    return ArrowLeft;\n  },\n\n  get Icon() {\n    return Icon;\n  },\n\n  get ArrowRight() {\n    return ArrowRight;\n  }\n\n};","map":{"version":3,"sources":["../../../../src/components/Carousel/index.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport styled, { css } from '../../utils/styled';\nimport { KeyCodes } from '../../utils/keyCodes';\nimport { remCalc } from '../../utils/remCalc';\nimport { InteractiveSurface, InteractiveSurfaceChangeEvent, InteractiveSurfaceProps } from '../InteractiveSurface';\nimport { Icon } from '../Icon';\nimport { StandardProps } from '../../common';\nimport { distance } from '../../distance';\nimport { getFontStyle } from '../../textStyles';\nexport interface CarouselChangeEvent {\n    /**\n     * The previously selected page index.\n     */\n    previousIndex: number;\n    /**\n     * The currently selected page index.\n     */\n    selectedIndex: number;\n}\nexport interface CarouselStopEvent {\n    /**\n     * The reason for stopping the autoplay mode.\n     */\n    reason: 'ended' | 'manual';\n    /**\n     * Resumes execution of the autoplay mode.\n     */\n    resume(): void;\n}\nexport interface CarouselProps extends StandardProps {\n    /**\n     * The default page index - only set for use in automatic mode.\n     */\n    defaultIndex?: number;\n    /**\n     * The currently selected page index - used in the controlled mode.\n     */\n    selectedIndex?: number;\n    /**\n     * Notification callback if the selected page index should change.\n     */\n    onPageChange?(e: CarouselChangeEvent): void;\n    /**\n     * The children, usually passed as a collection of elements.\n     */\n    children?: React.ReactNode;\n    /**\n     * Overrides the default container for bullets.\n     */\n    bulletsContainer?: React.ComponentType;\n    /**\n     * Overrides the default bullet point component.\n     */\n    bullet?: React.ComponentType<BulletProps>;\n    /**\n     * Displays the previous / next arrow. By default disabled.\n     * @default false\n     */\n    arrows?: boolean;\n    /**\n     * Event emitted once the Carousel autoplay stops.\n     */\n    onStop?(e: CarouselStopEvent): void;\n    /**\n     * Activate the autoplay mode, potentially with the time per slide\n     * in milliseconds. By default 3000.\n     * @default false\n     */\n    autoplay?: boolean | number;\n    /**\n     * Whether the Carousel can loop without stopping.\n     * @default false\n     */\n    infinite?: boolean;\n    /**\n     * Whether the Carousel can stop propagation so that links can be clicked\n     * @default false\n     */\n    opaque?: InteractiveSurfaceProps['opaque'];\n}\nexport interface DragStatus {\n    isDragging: boolean;\n    start?: Point;\n}\nexport interface Point {\n    x: number;\n    y: number;\n}\nexport interface CarouselState {\n    /**\n     * The currently selected page index.\n     */\n    selectedIndex: number;\n    /**\n     * Determines if the tab component is controlled from the outside or not.\n     */\n    controlled: boolean;\n    /**\n     * Status of the current swipe move.\n     */\n    dragStatus: DragStatus;\n}\nconst shiftThreshold = 0.3;\nconst animationDuration = '0.3s';\nconst animationFunction = 'ease-in-out';\nconst RootContainer = styled.div `\n  outline: none;\n`;\nconst DefaultBulletsContainer = styled.div `\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n`;\nexport interface BulletProps extends StandardProps {\n    /**\n     * Determines if the bullet is active or not.\n     */\n    active: boolean;\n    /**\n     * Fired once the bullet has been clicked.\n     */\n    onClick(): void;\n    /**\n     * Sets the bullet's index.\n     */\n    index: number;\n}\nconst ActiveBullet = css `\n  background-color: rgba(116, 118, 120, 1);\n`;\nconst DefaultBullet = styled.div<BulletProps> `\n  height: ${remCalc('12px')};\n  width: ${remCalc('12px')};\n  background-color: rgba(224, 225, 221, 1);\n  border-radius: 50%;\n  display: inline-block;\n  cursor: pointer;\n  margin: ${distance.xsmall};\n  ${props => (props.active ? ActiveBullet : '')};\n`;\nconst PageItem = styled.div `\n  min-width: 100%;\n`;\ninterface PagesContainerProps extends StandardProps {\n    selectedIndex: number;\n}\nconst PagesContainer = styled.div<PagesContainerProps> `\n  box-sizing: border-box;\n  display: flex;\n  position: relative;\n  left: ${props => -props.selectedIndex * 100}%;\n  transition: left ${animationDuration} ${animationFunction};\n`;\nconst Mask = styled.div `\n  position: relative;\n  box-sizing: border-box;\n  overflow: hidden;\n`;\nconst Arrow = styled.button `\n  ${getFontStyle({ size: 'medium' })}\n\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  background-color: transparent;\n  padding: 0;\n  border: none;\n  align-self: start;\n  cursor: pointer;\n  > i {\n    vertical-align: middle;\n  }\n`;\nconst ArrowLeft = styled(Arrow) `\n  left: 8px;\n`;\nconst ArrowRight = styled(Arrow) `\n  right: 8px;\n`;\nfunction calcNextPage(currentPage: number, totalPages: number, infinite: boolean = false) {\n    const maxIndex = totalPages - 1;\n    const nextPage = currentPage + 1;\n    return infinite && nextPage > maxIndex ? 0 : Math.min(nextPage, maxIndex);\n}\nfunction calcPrevPage(currentPage: number, totalPages: number, infinite: boolean = false) {\n    const prevPage = currentPage - 1;\n    const maxIndex = totalPages - 1;\n    return infinite && prevPage < 0 ? maxIndex : Math.max(prevPage, 0);\n}\nfunction calcLeftShiftPercent(selectedIndex: number) {\n    return selectedIndex * -100;\n}\nconst defaultAutoPlayTime = 3000;\n/**\n * The Carousel component displays a toggling list of content. Page can be changed using bullet\n * controls or swiping gestures.\n */\nexport class Carousel extends React.PureComponent<CarouselProps, CarouselState> {\n    private selects: Array<() => void> = [];\n    private pagesContainer: HTMLDivElement | null;\n    private autoPlayTimeout: any;\n    constructor(props: CarouselProps) {\n        super(props);\n        this.state = {\n            selectedIndex: props.selectedIndex || props.defaultIndex || 0,\n            controlled: props.selectedIndex !== undefined,\n            dragStatus: { isDragging: false },\n        };\n    }\n    UNSAFE_componentWillReceiveProps(nextProps: CarouselProps) {\n        const { selectedIndex } = nextProps;\n        const { controlled } = this.state;\n        if (controlled && typeof selectedIndex === 'number') {\n            this.setState({\n                selectedIndex,\n            });\n        }\n    }\n    componentDidMount() {\n        this.tryToPlay();\n    }\n    componentWillUnmount() {\n        this.stop();\n    }\n    private tryToPlay() {\n        this.stop();\n        const { autoplay } = this.props;\n        if (autoplay) {\n            this.play(typeof autoplay === 'number' ? autoplay : defaultAutoPlayTime);\n        }\n    }\n    private play(time: number) {\n        this.autoPlayTimeout = setInterval(this.swipeRightAuto, time);\n    }\n    private stop() {\n        this.autoPlayTimeout = clearInterval(this.autoPlayTimeout);\n    }\n    private resume = () => {\n        if (!this.autoPlayTimeout) {\n            this.tryToPlay();\n        }\n    };\n    private changePage(target: number, manual = true) {\n        const { onPageChange, onStop, children } = this.props;\n        const childrenCount = React.Children.count(children);\n        const { controlled, selectedIndex } = this.state;\n        const shouldStop = target >= childrenCount || target < 0;\n        if (manual || shouldStop) {\n            if (this.autoPlayTimeout) {\n                this.stop();\n                if (typeof onStop === 'function') {\n                    onStop({\n                        reason: manual ? 'manual' : 'ended',\n                        resume: this.resume,\n                    });\n                }\n            }\n        }\n        if (!shouldStop) {\n            if (typeof onPageChange === 'function') {\n                onPageChange({\n                    previousIndex: selectedIndex,\n                    selectedIndex: target,\n                });\n            }\n            if (!controlled) {\n                this.setState(() => ({\n                    selectedIndex: target,\n                }));\n            }\n        }\n    }\n    private dragTile = (e: InteractiveSurfaceChangeEvent) => {\n        const { controlled, selectedIndex, dragStatus } = this.state;\n        const shift = dragStatus.start ? e.x - dragStatus.start.x : 0;\n        if (controlled) {\n            e.release();\n        }\n        if (this.pagesContainer) {\n            if (e.active) {\n                if (!dragStatus.isDragging) {\n                    this.setState({ dragStatus: { isDragging: true, start: { x: e.x, y: e.y } } });\n                    this.setDragStyle(this.pagesContainer);\n                }\n                this.pagesContainer.style.left = `${calcLeftShiftPercent(selectedIndex) + shift * 100}%`;\n            }\n            else {\n                this.setState({ dragStatus: { isDragging: false, start: undefined } });\n                this.resetInitialStyle(this.pagesContainer);\n                this.checkPageChange(shift);\n            }\n        }\n    };\n    private checkPageChange(shift: number) {\n        const { selectedIndex } = this.state;\n        if (shift <= -shiftThreshold) {\n            const nextIndex = calcNextPage(selectedIndex, React.Children.count(this.props.children), this.props.infinite);\n            this.changePage(nextIndex);\n        }\n        else if (shift >= shiftThreshold) {\n            const prevIndex = calcPrevPage(selectedIndex, React.Children.count(this.props.children), this.props.infinite);\n            this.changePage(prevIndex);\n        }\n    }\n    private setDragStyle(node: HTMLElement) {\n        const style = node.style;\n        style.transitionProperty = 'unset';\n        style.transitionDuration = 'unset';\n        style.transitionTimingFunction = 'unset';\n    }\n    private resetInitialStyle(node: HTMLElement) {\n        const style = node.style;\n        // tslint:disable-next-line\n        style.left = null;\n        style.transitionProperty = 'left';\n        style.transitionDuration = animationDuration;\n        style.transitionTimingFunction = animationFunction;\n    }\n    private swipe(direction: number, manual: boolean) {\n        const { selectedIndex } = this.state;\n        const { children, infinite } = this.props;\n        const childrenCount = React.Children.count(children);\n        let nextIndex = selectedIndex;\n        if (direction === 1) {\n            nextIndex = calcNextPage(selectedIndex, childrenCount, infinite);\n        }\n        else if (direction === -1) {\n            nextIndex = calcPrevPage(selectedIndex, childrenCount, infinite);\n        }\n        this.changePage(nextIndex, manual);\n    }\n    private swipeLeft = () => {\n        this.swipe(-1, true);\n    };\n    private swipeRight = () => {\n        this.swipe(1, true);\n    };\n    private swipeRightAuto = () => {\n        this.swipe(1, false);\n    };\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const { children, infinite } = this.props;\n        const { selectedIndex } = this.state;\n        const childrenCount = React.Children.count(children);\n        let nextIndex = selectedIndex;\n        switch (e.keyCode) {\n            case KeyCodes.left:\n                nextIndex = calcPrevPage(selectedIndex, childrenCount, infinite);\n                break;\n            case KeyCodes.right:\n                nextIndex = calcNextPage(selectedIndex, childrenCount, infinite);\n                break;\n            case KeyCodes.end:\n                nextIndex = childrenCount - 1;\n                break;\n            case KeyCodes.home:\n                nextIndex = 0;\n                break;\n            default:\n                return;\n        }\n        this.changePage(nextIndex);\n    };\n    render() {\n        const { selectedIndex } = this.state;\n        const { children, theme, selectedIndex: _0, defaultIndex: _1, onPageChange: _2, bulletsContainer: CustomBulletsContainer, bullet: CustomBullet, arrows = false, infinite = false, opaque = false, ...props } = this.props;\n        const childrenCount = React.Children.count(children);\n        const bullets: Array<React.ReactChild> = [];\n        const items: Array<React.ReactChild> = [];\n        const selects = this.selects;\n        const BulletsContainer = CustomBulletsContainer || DefaultBulletsContainer;\n        const Bullet = CustomBullet || DefaultBullet;\n        React.Children.forEach(children, (element, index) => {\n            if (element && React.isValidElement(element)) {\n                const active = index === selectedIndex;\n                if (selects[index] === undefined) {\n                    selects[index] = () => this.changePage(index);\n                }\n                bullets.push(<Bullet theme={theme} key={`bullet-${index}`} active={active} index={index} onClick={selects[index]}/>);\n                items.push(<PageItem key={`item-${index}`}>{element}</PageItem>);\n            }\n        });\n        const disableLeft = !infinite && selectedIndex < 1;\n        const disableRight = !infinite && selectedIndex > childrenCount - 2;\n        return (<RootContainer {...props} onKeyDown={this.handleKeyDown} tabIndex={0}>\n        <Mask>\n          <InteractiveSurface theme={theme} onChange={this.dragTile} opaque={opaque}>\n            <PagesContainer ref={node => (this.pagesContainer = node)} selectedIndex={selectedIndex}>\n              {items}\n            </PagesContainer>\n          </InteractiveSurface>\n          {arrows && (<div>\n              <ArrowLeft onClick={this.swipeLeft} disabled={disableLeft} type=\"button\">\n                <Icon name=\"KeyboardArrowLeft\" size={2}/>\n              </ArrowLeft>\n              <ArrowRight onClick={this.swipeRight} disabled={disableRight} type=\"button\">\n                <Icon name=\"KeyboardArrowRight\" size={2}/>\n              </ArrowRight>\n            </div>)}\n        </Mask>\n        <BulletsContainer>{bullets}</BulletsContainer>\n      </RootContainer>);\n    }\n    static inner = {\n        get PageItem() { return PageItem as typeof PageItem; },\n        get RootContainer() { return RootContainer as typeof RootContainer; },\n        get Mask() { return Mask as typeof Mask; },\n        get InteractiveSurface() { return InteractiveSurface as typeof InteractiveSurface; },\n        get PagesContainer() { return PagesContainer as typeof PagesContainer; },\n        get ArrowLeft() { return ArrowLeft as typeof ArrowLeft; },\n        get Icon() { return Icon as typeof Icon; },\n        get ArrowRight() { return ArrowRight as typeof ArrowRight; }\n    };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import format from 'date-fns/esm/format';\nimport isAfter from 'date-fns/esm/isAfter';\nimport isValidDate from 'date-fns/esm/isValid';\nimport parse from 'date-fns/esm/parse';\n\nvar longFormatters = require('date-fns/_lib/format/longFormatters'); // This RegExp catches symbols escaped by quotes, and also\n// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`\n\n\nvar longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;\n/**\n * Date parsing\n * @param value\n * @param dateFormat\n * @param locale\n * @param strictParsing\n */\n\nexport function parseDate(value, dateFormat, locale, strictParsing) {\n  // tslint:disable-next-line\n  var parsedDate = null;\n  var localeObject = getLocaleObject(locale || '') || getDefaultLocale();\n  var strictParsingValueMatch = true;\n\n  if (Array.isArray(dateFormat)) {\n    dateFormat.forEach(function (df) {\n      var tryParseDate = parse(value, df, new Date(), {\n        locale: localeObject\n      });\n\n      if (strictParsing) {\n        strictParsingValueMatch = isValid(tryParseDate) && value === format(tryParseDate, df);\n      }\n\n      if (isValid(tryParseDate) && strictParsingValueMatch) {\n        parsedDate = tryParseDate;\n      }\n    });\n    return parsedDate;\n  }\n\n  parsedDate = parse(value, dateFormat, new Date(), {\n    locale: localeObject\n  });\n\n  if (strictParsing) {\n    strictParsingValueMatch = isValid(parsedDate) && value === format(parsedDate, dateFormat);\n  } else if (!isValid(parsedDate)) {\n    var match = dateFormat.match(longFormattingTokensRegExp);\n    var updatedDateFormat = match ? match.map(function (substring) {\n      var firstCharacter = substring[0];\n\n      if (firstCharacter === 'p' || firstCharacter === 'P') {\n        var longFormatter = longFormatters[firstCharacter];\n        return localeObject ? longFormatter(substring, localeObject.formatLong) : firstCharacter;\n      }\n\n      return substring;\n    }).join('') : dateFormat;\n\n    if (value.length > 0) {\n      parsedDate = parse(value, updatedDateFormat.slice(0, value.length), new Date());\n    }\n\n    if (!isValid(parsedDate)) {\n      parsedDate = new Date(value);\n    }\n  } // tslint:disable-next-line\n\n\n  return isValid(parsedDate) && strictParsingValueMatch ? parsedDate : null;\n}\nexport function getIsoDateFormat() {\n  return 'yyyy-MM-dd';\n}\n\nfunction getLocaleObject(localeSpec) {\n  if (typeof localeSpec === 'string') {\n    // Treat it as a locale name registered by registerLocale\n    // tslint:disable-next-line\n    return window.__localeData__ ? window.__localeData__[localeSpec] : null;\n  } else {\n    // Treat it as a raw date-fns locale object\n    return localeSpec;\n  }\n}\n\nfunction getDefaultLocale() {\n  return window.__localeId__;\n}\n\nfunction isValid(date) {\n  return isValidDate(date) && isAfter(date, new Date('1/1/1000'));\n}\n/**\n * Date Formatting\n * @param date Date\n * @param formatStr string\n * @param locale string\n */\n\n\nfunction formatDate(date, formatStr) {\n  var locale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  if (locale === 'en') {\n    return format(date, formatStr);\n  }\n\n  var localeObj = getLocaleObject(locale);\n\n  if (locale && !localeObj) {\n    console.warn(\"A locale object was not found for the provided string [\\\"\".concat(locale, \"\\\"].\"));\n  }\n\n  if (!localeObj && !!getDefaultLocale() && !!getLocaleObject(getDefaultLocale())) {\n    localeObj = getLocaleObject(getDefaultLocale());\n  }\n\n  return format(date, formatStr, {\n    // tslint:disable-next-line\n    locale: localeObj ? localeObj : null\n  });\n}\n\nexport function safeDateFormat(date, _ref) {\n  var dateFormat = _ref.dateFormat,\n      locale = _ref.locale;\n  return date && formatDate(date, Array.isArray(dateFormat) ? dateFormat[0] : dateFormat, locale) || '';\n}","map":{"version":3,"sources":["../../../src/utils/date.ts"],"names":[],"mappings":"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","sourcesContent":["import { Locale } from 'date-fns';\nimport format from 'date-fns/esm/format';\nimport isAfter from 'date-fns/esm/isAfter';\nimport isValidDate from 'date-fns/esm/isValid';\nimport parse from 'date-fns/esm/parse';\n\nconst longFormatters = require('date-fns/_lib/format/longFormatters');\n\ndeclare global {\n  interface Window {\n    __localeData__: Object;\n    __localeId__: string;\n  }\n}\n\n// This RegExp catches symbols escaped by quotes, and also\n// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`\nconst longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;\n\n/**\n * Date parsing\n * @param value\n * @param dateFormat\n * @param locale\n * @param strictParsing\n */\nexport function parseDate(\n  value: string,\n  dateFormat: string | Array<string>,\n  locale?: Locale | string,\n  strictParsing?: boolean,\n) {\n  // tslint:disable-next-line\n  let parsedDate = null;\n  const localeObject = getLocaleObject(locale || '') || getDefaultLocale();\n  let strictParsingValueMatch = true;\n  if (Array.isArray(dateFormat)) {\n    dateFormat.forEach(df => {\n      const tryParseDate = parse(value, df, new Date(), { locale: localeObject });\n      if (strictParsing) {\n        strictParsingValueMatch = isValid(tryParseDate) && value === format(tryParseDate, df);\n      }\n      if (isValid(tryParseDate) && strictParsingValueMatch) {\n        parsedDate = tryParseDate;\n      }\n    });\n    return parsedDate;\n  }\n\n  parsedDate = parse(value, dateFormat, new Date(), { locale: localeObject });\n\n  if (strictParsing) {\n    strictParsingValueMatch = isValid(parsedDate) && value === format(parsedDate, dateFormat);\n  } else if (!isValid(parsedDate)) {\n    const match = dateFormat.match(longFormattingTokensRegExp);\n    const updatedDateFormat = match\n      ? match\n          .map(substring => {\n            const firstCharacter = substring[0];\n            if (firstCharacter === 'p' || firstCharacter === 'P') {\n              const longFormatter = longFormatters[firstCharacter];\n              return localeObject ? longFormatter(substring, localeObject.formatLong) : firstCharacter;\n            }\n            return substring;\n          })\n          .join('')\n      : dateFormat;\n\n    if (value.length > 0) {\n      parsedDate = parse(value, updatedDateFormat.slice(0, value.length), new Date());\n    }\n\n    if (!isValid(parsedDate)) {\n      parsedDate = new Date(value);\n    }\n  }\n\n  // tslint:disable-next-line\n  return isValid(parsedDate) && strictParsingValueMatch ? parsedDate : null;\n}\n\nexport function getIsoDateFormat() {\n  return 'yyyy-MM-dd';\n}\n\nfunction getLocaleObject(localeSpec: string | Locale) {\n  if (typeof localeSpec === 'string') {\n    // Treat it as a locale name registered by registerLocale\n    // tslint:disable-next-line\n    return window.__localeData__ ? window.__localeData__[localeSpec] : null;\n  } else {\n    // Treat it as a raw date-fns locale object\n    return localeSpec;\n  }\n}\n\nfunction getDefaultLocale() {\n  return window.__localeId__;\n}\n\nfunction isValid(date: Date) {\n  return isValidDate(date) && isAfter(date, new Date('1/1/1000'));\n}\n\n/**\n * Date Formatting\n * @param date Date\n * @param formatStr string\n * @param locale string\n */\nfunction formatDate(date: Date, formatStr: string, locale: string | Locale = '') {\n  if (locale === 'en') {\n    return format(date, formatStr);\n  }\n  let localeObj = getLocaleObject(locale);\n  if (locale && !localeObj) {\n    console.warn(`A locale object was not found for the provided string [\"${locale}\"].`);\n  }\n  if (!localeObj && !!getDefaultLocale() && !!getLocaleObject(getDefaultLocale())) {\n    localeObj = getLocaleObject(getDefaultLocale());\n  }\n  return format(date, formatStr, {\n    // tslint:disable-next-line\n    locale: localeObj ? localeObj : null,\n  });\n}\n\nexport function safeDateFormat(\n  date: Date | undefined,\n  { dateFormat, locale }: { dateFormat: string | Array<string>; locale?: string | Locale },\n) {\n  return (date && formatDate(date, Array.isArray(dateFormat) ? dateFormat[0] : dateFormat, locale)) || '';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
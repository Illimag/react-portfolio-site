{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport * as React from 'react';\n/**\n * The functional component to handle tabs.\n * DEPRECATED: Please use `withTabControl` instead.\n * @deprecated\n */\n\nexport class TabControl extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.selects = [];\n\n    this.changeIndex = target => {\n      const change = this.props.onTabChange;\n\n      if (typeof change === 'function') {\n        change({\n          previousIndex: this.state.selectedIndex,\n          selectedIndex: target\n        });\n      }\n\n      if (!this.state.controlled) {\n        this.setState({\n          selectedIndex: target\n        });\n      }\n    };\n\n    this.state = {\n      selectedIndex: props.selectedIndex || props.defaultIndex || 0,\n      controlled: props.selectedIndex !== undefined\n    };\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    const selectedIndex = nextProps.selectedIndex;\n\n    if (this.state.controlled && typeof selectedIndex === 'number') {\n      this.setState({\n        selectedIndex\n      });\n    }\n  }\n\n  render() {\n    const selectedIndex = this.state.selectedIndex;\n    const {\n      children,\n      render\n    } = this.props;\n    const items = [];\n    const selects = this.selects;\n    React.Children.forEach(children, (element, index) => {\n      if (element && React.isValidElement(element)) {\n        const active = index === selectedIndex;\n\n        if (selects[index] === undefined) {\n          selects[index] = () => this.changeIndex(index);\n        }\n\n        items.push({\n          onSelect: selects[index],\n          active,\n          element\n        });\n      }\n    });\n    return render(items);\n  }\n\n}\n\nfunction isTabPage(child) {\n  return !!child;\n}\n\nfunction useTabControl({\n  children,\n  selectedIndex,\n  defaultIndex,\n  onTabChange\n}) {\n  const [controlled] = React.useState(selectedIndex !== undefined);\n  const [activeTabIndex, setActiveTabIndex] = React.useState(selectedIndex || defaultIndex || 0);\n  React.useEffect(() => {\n    if (controlled && typeof selectedIndex === 'number') {\n      setActiveTabIndex(selectedIndex);\n    }\n  }, [selectedIndex]);\n  const elements = React.useMemo(() => (React.Children.map(children, child => React.isValidElement(child) ? child : undefined) || []).filter(isTabPage), [children]);\n  const headers = React.useMemo(() => elements.map(child => child.props.header), [elements]);\n  const onSelect = React.useCallback(selectedIndex => {\n    setActiveTabIndex(previousIndex => {\n      if (typeof onTabChange === 'function') {\n        onTabChange({\n          previousIndex,\n          selectedIndex\n        });\n      }\n\n      return controlled ? previousIndex : selectedIndex;\n    });\n  }, [onTabChange, controlled]);\n  return {\n    elements,\n    headers,\n    activeTabIndex,\n    onSelect,\n\n    isActive(index) {\n      return activeTabIndex === index;\n    }\n\n  };\n}\n\nexport function withTabControl(Component) {\n  const TabControl = Object.assign(_a => {\n    var {\n      children,\n      tabItemRenderer: Element\n    } = _a,\n        rest = __rest(_a, [\"children\", \"tabItemRenderer\"]);\n\n    const {\n      elements,\n      headers,\n      activeTabIndex,\n      isActive,\n      onSelect\n    } = useTabControl(Object.assign({\n      children\n    }, rest));\n    return React.createElement(Component, Object.assign({}, rest, {\n      headers: headers,\n      activeIndex: activeTabIndex,\n      onSelect: onSelect\n    }), elements.map((child, i) => React.createElement(Element, {\n      key: `item-${i}`,\n      active: isActive(i)\n    }, child)));\n  }, {\n    inner: {\n      get Component() {\n        return Component;\n      }\n\n    }\n  });\n  return TabControl;\n}","map":{"version":3,"sources":["../../../../src/components/TabControl/index.tsx"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AAgEA;;;;;;AAKA,OAAM,MAAO,UAAP,SAA0B,KAAK,CAAC,aAAhC,CAA+E;AAEjF,EAAA,WAAA,CAAY,KAAZ,EAAkC;AAC9B,UAAM,KAAN;AAFI,SAAA,OAAA,GAA6B,EAA7B;;AAgBA,SAAA,WAAA,GAAe,MAAD,IAAmB;AACrC,YAAM,MAAM,GAAG,KAAK,KAAL,CAAW,WAA1B;;AACA,UAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,QAAA,MAAM,CAAC;AACH,UAAA,aAAa,EAAE,KAAK,KAAL,CAAW,aADvB;AAEH,UAAA,aAAa,EAAE;AAFZ,SAAD,CAAN;AAIH;;AACD,UAAI,CAAC,KAAK,KAAL,CAAW,UAAhB,EAA4B;AACxB,aAAK,QAAL,CAAc;AACV,UAAA,aAAa,EAAE;AADL,SAAd;AAGH;AACJ,KAbO;;AAbJ,SAAK,KAAL,GAAa;AACT,MAAA,aAAa,EAAE,KAAK,CAAC,aAAN,IAAuB,KAAK,CAAC,YAA7B,IAA6C,CADnD;AAET,MAAA,UAAU,EAAE,KAAK,CAAC,aAAN,KAAwB;AAF3B,KAAb;AAIH;;AACD,EAAA,gCAAgC,CAAC,SAAD,EAA2B;AACvD,UAAM,aAAa,GAAG,SAAS,CAAC,aAAhC;;AACA,QAAI,KAAK,KAAL,CAAW,UAAX,IAAyB,OAAO,aAAP,KAAyB,QAAtD,EAAgE;AAC5D,WAAK,QAAL,CAAc;AACV,QAAA;AADU,OAAd;AAGH;AACJ;;AAeD,EAAA,MAAM,GAAA;AACF,UAAM,aAAa,GAAG,KAAK,KAAL,CAAW,aAAjC;AACA,UAAM;AAAE,MAAA,QAAF;AAAY,MAAA;AAAZ,QAAuB,KAAK,KAAlC;AACA,UAAM,KAAK,GAA0B,EAArC;AACA,UAAM,OAAO,GAAG,KAAK,OAArB;AACA,IAAA,KAAK,CAAC,QAAN,CAAe,OAAf,CAAuB,QAAvB,EAAiC,CAAC,OAAD,EAAmC,KAAnC,KAA4C;AACzE,UAAI,OAAO,IAAI,KAAK,CAAC,cAAN,CAAqB,OAArB,CAAf,EAA8C;AAC1C,cAAM,MAAM,GAAG,KAAK,KAAK,aAAzB;;AACA,YAAI,OAAO,CAAC,KAAD,CAAP,KAAmB,SAAvB,EAAkC;AAC9B,UAAA,OAAO,CAAC,KAAD,CAAP,GAAiB,MAAM,KAAK,WAAL,CAAiB,KAAjB,CAAvB;AACH;;AACD,QAAA,KAAK,CAAC,IAAN,CAAW;AACP,UAAA,QAAQ,EAAE,OAAO,CAAC,KAAD,CADV;AAEP,UAAA,MAFO;AAGP,UAAA;AAHO,SAAX;AAKH;AACJ,KAZD;AAaA,WAAO,MAAM,CAAC,KAAD,CAAb;AACH;;AAlDgF;;AAoDrF,SAAS,SAAT,CAAmB,KAAnB,EAA0D;AACtD,SAAO,CAAC,CAAC,KAAT;AACH;;AAOD,SAAS,aAAT,CAAuB;AAAE,EAAA,QAAF;AAAY,EAAA,aAAZ;AAA2B,EAAA,YAA3B;AAAyC,EAAA;AAAzC,CAAvB,EAAmG;AAC/F,QAAM,CAAC,UAAD,IAAe,KAAK,CAAC,QAAN,CAAe,aAAa,KAAK,SAAjC,CAArB;AACA,QAAM,CAAC,cAAD,EAAiB,iBAAjB,IAAsC,KAAK,CAAC,QAAN,CAAe,aAAa,IAAI,YAAjB,IAAiC,CAAhD,CAA5C;AACA,EAAA,KAAK,CAAC,SAAN,CAAgB,MAAK;AACjB,QAAI,UAAU,IAAI,OAAO,aAAP,KAAyB,QAA3C,EAAqD;AACjD,MAAA,iBAAiB,CAAC,aAAD,CAAjB;AACH;AACJ,GAJD,EAIG,CAAC,aAAD,CAJH;AAKA,QAAM,QAAQ,GAAG,KAAK,CAAC,OAAN,CAAc,MAAM,CAAC,KAAK,CAAC,QAAN,CAAe,GAAf,CAAmB,QAAnB,EAA6B,KAAK,IAAK,KAAK,CAAC,cAAN,CAAqB,KAArB,IAA8B,KAA9B,GAAsC,SAA7E,KAA4F,EAA7F,EAAiG,MAAjG,CAAwG,SAAxG,CAApB,EAAwI,CAAC,QAAD,CAAxI,CAAjB;AACA,QAAM,OAAO,GAAG,KAAK,CAAC,OAAN,CAAc,MAAM,QAAQ,CAAC,GAAT,CAAa,KAAK,IAAI,KAAK,CAAC,KAAN,CAAY,MAAlC,CAApB,EAA+D,CAAC,QAAD,CAA/D,CAAhB;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,WAAN,CAAmB,aAAD,IAA0B;AACzD,IAAA,iBAAiB,CAAC,aAAa,IAAG;AAC9B,UAAI,OAAO,WAAP,KAAuB,UAA3B,EAAuC;AACnC,QAAA,WAAW,CAAC;AACR,UAAA,aADQ;AAER,UAAA;AAFQ,SAAD,CAAX;AAIH;;AACD,aAAO,UAAU,GAAG,aAAH,GAAmB,aAApC;AACH,KARgB,CAAjB;AASH,GAVgB,EAUd,CAAC,WAAD,EAAc,UAAd,CAVc,CAAjB;AAWA,SAAO;AACH,IAAA,QADG;AAEH,IAAA,OAFG;AAGH,IAAA,cAHG;AAIH,IAAA,QAJG;;AAKH,IAAA,QAAQ,CAAC,KAAD,EAAc;AAClB,aAAO,cAAc,KAAK,KAA1B;AACH;;AAPE,GAAP;AASH;;AASD,OAAM,SAAU,cAAV,CAA0D,SAA1D,EAA2F;AAC7F,QAAM,UAAU,GAAG,MAAM,CAAC,MAAP,CAAiB,EAAD,IAAoD;QAAnD;AAAE,MAAA,QAAF;AAAY,MAAA,eAAe,EAAE;AAA7B,QAAoC,E;QAAE,IAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,UAAA,EAAA,iBAAA,CAAA,C;;AACtE,UAAM;AAAE,MAAA,QAAF;AAAY,MAAA,OAAZ;AAAqB,MAAA,cAArB;AAAqC,MAAA,QAArC;AAA+C,MAAA;AAA/C,QAA4D,aAAa,CAAA,MAAA,CAAA,MAAA,CAAA;AAC3E,MAAA;AAD2E,KAAA,EAExE,IAFwE,CAAA,CAA/E;AAIA,WAAQ,KAAA,CAAA,aAAA,CAAC,SAAD,EAAU,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,IAAL,EAAgB;AAAE,MAAA,OAAO,EAAE,OAAX;AAAoB,MAAA,WAAW,EAAE,cAAjC;AAAiD,MAAA,QAAQ,EAAE;AAA3D,KAAhB,CAAV,EACP,QAAQ,CAAC,GAAT,CAAa,CAAC,KAAD,EAAQ,CAAR,KAAe,KAAA,CAAA,aAAA,CAAC,OAAD,EAAQ;AAAC,MAAA,GAAG,EAAE,QAAQ,CAAC,EAAf;AAAmB,MAAA,MAAM,EAAE,QAAQ,CAAC,CAAD;AAAnC,KAAR,EACxB,KADwB,CAA5B,CADO,CAAR;AAKH,GAVkB,EAUuE;AAAE,IAAA,KAAK,EAAE;AAC3F,UAAI,SAAJ,GAAa;AAAK,eAAO,SAAP;AAAuC;;AADkC;AAAT,GAVvE,CAAnB;AAaA,SAAO,UAAP;AACH","sourcesContent":["import * as React from 'react';\nimport { TabPageProps } from '../TabPage';\nimport { Omit } from '../../common';\nimport { TabItemProps } from '../ContentSwitch/ContentSwitch.part';\nexport interface TabControlItem {\n    /**\n     * The element to be shown.\n     */\n    element: React.ReactNode;\n    /**\n     * Gets if the item is currently active.\n     */\n    active: boolean;\n    /**\n     * Callback to use when the item should be active.\n     */\n    onSelect(): void;\n}\nexport interface TabChangeEvent {\n    /**\n     * The previously selected tab / index.\n     */\n    previousIndex: number;\n    /**\n     * The currently selected tab / index.\n     */\n    selectedIndex: number;\n}\nexport interface TabOptions {\n    /**\n     * The default index - only set for use in automatic mode.\n     */\n    defaultIndex?: number;\n    /**\n     * The currently selected index - used in the controlled mode.\n     */\n    selectedIndex?: number;\n    /**\n     * Notification callback if the selected tab index should change.\n     */\n    onTabChange?(e: TabChangeEvent): void;\n}\n/**\n * @deprecated\n */\nexport interface TabControlProps extends TabOptions {\n    /**\n     * The children, usually passed as a collection of TabPage elements.\n     */\n    render(items: Array<TabControlItem>): React.ReactNode;\n}\n/**\n * @deprecated\n */\nexport interface TabControlState {\n    /**\n     * The currently selected index.\n     */\n    selectedIndex: number;\n    /**\n     * Determines if the tab component is controlled from the outside or not.\n     */\n    controlled: boolean;\n}\n/**\n * The functional component to handle tabs.\n * DEPRECATED: Please use `withTabControl` instead.\n * @deprecated\n */\nexport class TabControl extends React.PureComponent<TabControlProps, TabControlState> {\n    private selects: Array<() => void> = [];\n    constructor(props: TabControlProps) {\n        super(props);\n        this.state = {\n            selectedIndex: props.selectedIndex || props.defaultIndex || 0,\n            controlled: props.selectedIndex !== undefined,\n        };\n    }\n    UNSAFE_componentWillReceiveProps(nextProps: TabControlProps) {\n        const selectedIndex = nextProps.selectedIndex;\n        if (this.state.controlled && typeof selectedIndex === 'number') {\n            this.setState({\n                selectedIndex,\n            });\n        }\n    }\n    private changeIndex = (target: number) => {\n        const change = this.props.onTabChange;\n        if (typeof change === 'function') {\n            change({\n                previousIndex: this.state.selectedIndex,\n                selectedIndex: target,\n            });\n        }\n        if (!this.state.controlled) {\n            this.setState({\n                selectedIndex: target,\n            });\n        }\n    };\n    render() {\n        const selectedIndex = this.state.selectedIndex;\n        const { children, render } = this.props;\n        const items: Array<TabControlItem> = [];\n        const selects = this.selects;\n        React.Children.forEach(children, (element: React.ReactElement<any>, index) => {\n            if (element && React.isValidElement(element)) {\n                const active = index === selectedIndex;\n                if (selects[index] === undefined) {\n                    selects[index] = () => this.changeIndex(index);\n                }\n                items.push({\n                    onSelect: selects[index],\n                    active,\n                    element,\n                });\n            }\n        });\n        return render(items);\n    }\n}\nfunction isTabPage(child: React.ReactElement<TabPageProps>): child is React.ReactElement<TabPageProps> {\n    return !!child;\n}\ninterface UseTabSwitcherParams {\n    children: React.ReactNode;\n    selectedIndex?: number;\n    defaultIndex?: number;\n    onTabChange?(e: TabChangeEvent): void;\n}\nfunction useTabControl({ children, selectedIndex, defaultIndex, onTabChange }: UseTabSwitcherParams) {\n    const [controlled] = React.useState(selectedIndex !== undefined);\n    const [activeTabIndex, setActiveTabIndex] = React.useState(selectedIndex || defaultIndex || 0);\n    React.useEffect(() => {\n        if (controlled && typeof selectedIndex === 'number') {\n            setActiveTabIndex(selectedIndex);\n        }\n    }, [selectedIndex]);\n    const elements = React.useMemo(() => (React.Children.map(children, child => (React.isValidElement(child) ? child : undefined)) || []).filter(isTabPage), [children]);\n    const headers = React.useMemo(() => elements.map(child => child.props.header), [elements]);\n    const onSelect = React.useCallback((selectedIndex: number) => {\n        setActiveTabIndex(previousIndex => {\n            if (typeof onTabChange === 'function') {\n                onTabChange({\n                    previousIndex,\n                    selectedIndex,\n                });\n            }\n            return controlled ? previousIndex : selectedIndex;\n        });\n    }, [onTabChange, controlled]);\n    return {\n        elements,\n        headers,\n        activeTabIndex,\n        onSelect,\n        isActive(index: number) {\n            return activeTabIndex === index;\n        },\n    };\n}\nexport interface TabControlHolderProps {\n    headers: Array<React.ReactChild>;\n    activeIndex?: number;\n    onSelect(index: number): void;\n}\nexport interface WithTabControlProps {\n    tabItemRenderer: React.ElementType<TabItemProps>;\n}\nexport function withTabControl<T extends TabControlHolderProps>(Component: React.ComponentType<T>) {\n    const TabControl = Object.assign(((({ children, tabItemRenderer: Element, ...rest }) => {\n        const { elements, headers, activeTabIndex, isActive, onSelect } = useTabControl({\n            children,\n            ...rest,\n        });\n        return (<Component {...rest as any} headers={headers} activeIndex={activeTabIndex} onSelect={onSelect}>\n        {elements.map((child, i) => (<Element key={`item-${i}`} active={isActive(i)}>\n            {child}\n          </Element>))}\n      </Component>);\n    }) as React.FC<TabOptions & WithTabControlProps & Omit<T, keyof TabControlHolderProps>>), { inner: {\n            get Component() { return Component as typeof Component; }\n        } });\n    return TabControl;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
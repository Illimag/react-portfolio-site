{"ast":null,"code":"import * as React from 'react';\nexport function checkAllocation(layout, row, col, rowSpan, colSpan) {\n  const {\n    allocations,\n    flexCols,\n    flexRows\n  } = layout;\n\n  for (let r = row, l = row + rowSpan; r < l; r++) {\n    if (r >= allocations.length && !flexRows) {\n      return false;\n    }\n\n    const allocation = allocations[r];\n\n    for (let c = col, l = col + colSpan; c < l; c++) {\n      if (allocation) {\n        if (c >= allocation.length && !flexCols || allocation[c]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\nexport function findAllocation(layout, proposedAllocation = {}) {\n  const {\n    colSpan = 1,\n    rowSpan = 1,\n    row,\n    column: col\n  } = proposedAllocation;\n\n  if (row === undefined || col === undefined) {\n    const {\n      allocations,\n      flexCols,\n      flexRows\n    } = layout;\n    const infty = Number.POSITIVE_INFINITY;\n    const maxRows = flexRows ? infty : allocations.length - 1;\n    const maxCols = flexCols ? infty : allocations[0].length - 1;\n\n    for (let r = row || 0; r <= (row || maxRows); r++) {\n      for (let c = col || 0; c <= (col || maxCols); c++) {\n        if (checkAllocation(layout, r, c, rowSpan, colSpan)) {\n          return {\n            ci: c,\n            cf: c + colSpan,\n            ri: r,\n            rf: r + rowSpan\n          };\n        }\n      }\n    }\n  } else {\n    return {\n      ci: col,\n      cf: col + colSpan,\n      ri: row,\n      rf: row + rowSpan\n    };\n  }\n\n  return undefined;\n}\nexport function updateAllocation(allocations, allocation) {\n  while (allocations.length < allocation.ri) {\n    appendRow(allocations);\n  }\n\n  while (allocations[0].length < allocation.ci) {\n    appendColumn(allocations);\n  }\n\n  for (let row = allocation.ri; row < allocation.rf; row++) {\n    if (row === allocations.length) {\n      appendRow(allocations);\n    }\n\n    for (let col = allocation.ci; col < allocation.cf; col++) {\n      if (col === allocations[0].length) {\n        appendColumn(allocations);\n      }\n\n      allocations[row][col] = true;\n    }\n  }\n}\nexport function createAllocations(dim) {\n  const allocations = [];\n  const rows = Array.isArray(dim.rows) ? dim.rows.length : dim.rows || 1;\n  const cols = Array.isArray(dim.columns) ? dim.columns.length : dim.columns || 1;\n\n  for (let row = 0; row < rows; ++row) {\n    const allocation = createRow(cols);\n    allocations.push(allocation);\n  }\n\n  return {\n    allocations,\n    flexRows: dim.rows === undefined && dim.columns !== undefined,\n    flexCols: dim.columns === undefined\n  };\n}\n\nfunction appendColumn(allocations) {\n  for (const row of allocations) {\n    row.push(false);\n  }\n}\n\nfunction appendRow(allocations) {\n  const newRow = createRow(allocations[0].length);\n  allocations.push(newRow);\n}\n\nfunction createRow(cols) {\n  const allocation = [];\n\n  for (let col = 0; col < cols; ++col) {\n    allocation.push(false);\n  }\n\n  return allocation;\n}\n\nfunction createCell(layout, proposed) {\n  if (!proposed.hidden) {\n    const foundAllocation = findAllocation(layout, proposed);\n\n    if (foundAllocation) {\n      updateAllocation(layout.allocations, foundAllocation);\n      return {\n        column: foundAllocation.ci,\n        row: foundAllocation.ri,\n        colSpan: foundAllocation.cf - foundAllocation.ci,\n        rowSpan: foundAllocation.rf - foundAllocation.ri\n      };\n    }\n\n    return undefined;\n  }\n\n  return {\n    column: 0,\n    row: 0,\n    colSpan: 0,\n    rowSpan: 0\n  };\n}\n\nexport function calcLayout(children, dim) {\n  const layout = createAllocations(dim);\n  const cells = [];\n  React.Children.forEach(children, (child, index) => {\n    if (typeof child === 'object' && child) {\n      const {\n        row,\n        column\n      } = child.props;\n\n      if (row !== undefined && column !== undefined) {\n        cells[index] = createCell(layout, child.props);\n      }\n    }\n  });\n  React.Children.forEach(children, (child, index) => {\n    if (typeof child === 'object' && child && !cells[index]) {\n      cells[index] = createCell(layout, child.props);\n    }\n  });\n  return {\n    cells,\n    rows: layout.allocations.length,\n    columns: layout.allocations[0].length\n  };\n}","map":{"version":3,"sources":["../../../src/utils/gridLayout.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nexport interface GridCellDefinition {\n  /**\n   * The optional number of spanned columns. By default only 1 column is spanned.\n   * @default 1\n   */\n  colSpan?: number;\n  /**\n   * The optional number of spanned columns. By default only 1 row is spanned.\n   * @default 1\n   */\n  rowSpan?: number;\n  /**\n   * The 0-based column where the area should be displayed.\n   */\n  column?: number;\n  /**\n   * The 0-based row where the area should be displayed.\n   */\n  row?: number;\n  /**\n   * Optionally sets the tile to be hidden, so that it does not consume space.\n   */\n  hidden?: boolean;\n}\n\nexport interface GridLayoutCell {\n  ri: number;\n  rf: number;\n  ci: number;\n  cf: number;\n}\n\nexport interface GridAllocation {\n  column: number;\n  row: number;\n  colSpan: number;\n  rowSpan: number;\n}\n\nexport interface GridAllocationLayout {\n  allocations: Array<Array<boolean>>;\n  flexRows: boolean;\n  flexCols: boolean;\n}\n\nexport interface GridDimension {\n  rows?: number | Array<string>;\n  columns?: number | Array<string>;\n}\n\nexport function checkAllocation(\n  layout: GridAllocationLayout,\n  row: number,\n  col: number,\n  rowSpan: number,\n  colSpan: number,\n) {\n  const { allocations, flexCols, flexRows } = layout;\n\n  for (let r = row, l = row + rowSpan; r < l; r++) {\n    if (r >= allocations.length && !flexRows) {\n      return false;\n    }\n\n    const allocation = allocations[r];\n\n    for (let c = col, l = col + colSpan; c < l; c++) {\n      if (allocation) {\n        if ((c >= allocation.length && !flexCols) || allocation[c]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function findAllocation(layout: GridAllocationLayout, proposedAllocation: Partial<GridAllocation> = {}) {\n  const { colSpan = 1, rowSpan = 1, row, column: col } = proposedAllocation;\n\n  if (row === undefined || col === undefined) {\n    const { allocations, flexCols, flexRows } = layout;\n    const infty = Number.POSITIVE_INFINITY;\n    const maxRows = flexRows ? infty : allocations.length - 1;\n    const maxCols = flexCols ? infty : allocations[0].length - 1;\n\n    for (let r = row || 0; r <= (row || maxRows); r++) {\n      for (let c = col || 0; c <= (col || maxCols); c++) {\n        if (checkAllocation(layout, r, c, rowSpan, colSpan)) {\n          return {\n            ci: c,\n            cf: c + colSpan,\n            ri: r,\n            rf: r + rowSpan,\n          };\n        }\n      }\n    }\n  } else {\n    return {\n      ci: col,\n      cf: col + colSpan,\n      ri: row,\n      rf: row + rowSpan,\n    };\n  }\n\n  return undefined;\n}\n\nexport function updateAllocation(allocations: Array<Array<boolean>>, allocation: GridLayoutCell) {\n  while (allocations.length < allocation.ri) {\n    appendRow(allocations);\n  }\n\n  while (allocations[0].length < allocation.ci) {\n    appendColumn(allocations);\n  }\n\n  for (let row = allocation.ri; row < allocation.rf; row++) {\n    if (row === allocations.length) {\n      appendRow(allocations);\n    }\n\n    for (let col = allocation.ci; col < allocation.cf; col++) {\n      if (col === allocations[0].length) {\n        appendColumn(allocations);\n      }\n\n      allocations[row][col] = true;\n    }\n  }\n}\n\nexport function createAllocations(dim: GridDimension) {\n  const allocations: Array<Array<boolean>> = [];\n  const rows = Array.isArray(dim.rows) ? dim.rows.length : dim.rows || 1;\n  const cols = Array.isArray(dim.columns) ? dim.columns.length : dim.columns || 1;\n\n  for (let row = 0; row < rows; ++row) {\n    const allocation = createRow(cols);\n    allocations.push(allocation);\n  }\n\n  return {\n    allocations,\n    flexRows: dim.rows === undefined && dim.columns !== undefined,\n    flexCols: dim.columns === undefined,\n  };\n}\n\nfunction appendColumn(allocations: Array<Array<boolean>>) {\n  for (const row of allocations) {\n    row.push(false);\n  }\n}\n\nfunction appendRow(allocations: Array<Array<boolean>>) {\n  const newRow = createRow(allocations[0].length);\n  allocations.push(newRow);\n}\n\nfunction createRow(cols: number) {\n  const allocation: Array<boolean> = [];\n\n  for (let col = 0; col < cols; ++col) {\n    allocation.push(false);\n  }\n\n  return allocation;\n}\n\nfunction createCell(layout: GridAllocationLayout, proposed: GridCellDefinition): GridAllocation | undefined {\n  if (!proposed.hidden) {\n    const foundAllocation = findAllocation(layout, proposed);\n\n    if (foundAllocation) {\n      updateAllocation(layout.allocations, foundAllocation);\n      return {\n        column: foundAllocation.ci,\n        row: foundAllocation.ri,\n        colSpan: foundAllocation.cf - foundAllocation.ci,\n        rowSpan: foundAllocation.rf - foundAllocation.ri,\n      };\n    }\n\n    return undefined;\n  }\n\n  return {\n    column: 0,\n    row: 0,\n    colSpan: 0,\n    rowSpan: 0,\n  };\n}\n\nexport function calcLayout(children: React.ReactNode, dim: GridDimension) {\n  const layout = createAllocations(dim);\n  const cells: Array<GridAllocation | undefined> = [];\n\n  React.Children.forEach(children, (child, index) => {\n    if (typeof child === 'object' && child) {\n      const { row, column } = (child as any).props;\n\n      if (row !== undefined && column !== undefined) {\n        cells[index] = createCell(layout, (child as any).props);\n      }\n    }\n  });\n\n  React.Children.forEach(children, (child, index) => {\n    if (typeof child === 'object' && child && !cells[index]) {\n      cells[index] = createCell(layout, (child as any).props);\n    }\n  });\n\n  return {\n    cells,\n    rows: layout.allocations.length,\n    columns: layout.allocations[0].length,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport * as React from 'react';\nimport styled from '../../utils/styled';\nimport { calcLayout } from '../../utils/gridLayout';\nimport { isIE } from '../../utils/browser';\nconst StyledGridWrapper = styled.div`\n  position: relative;\n`;\n\nfunction addPx(original, space) {\n  if (original.endsWith('px')) {\n    const dim = +original.replace('px', '');\n    return `${dim + space}px`;\n  }\n\n  return original;\n}\n\nfunction computeIeRows(rows, spacing) {\n  if (isIE === 'IE11') {\n    const [, rowSpace] = spacing;\n\n    if (rowSpace && rowSpace.endsWith('px')) {\n      const space = +rowSpace.replace('px', '');\n\n      if (space) {\n        const end = rows.length - 1;\n        return rows.map((row, i) => i !== end ? addPx(row, space) : row).join(' ');\n      }\n    }\n  }\n\n  return rows.join(' ');\n}\n\nconst BasicGridLayout = styled.div`\n  height: 100%;\n  width: 100%;\n  display: -ms-grid;\n  display: grid;\n  -ms-grid-columns: ${props => props.columns.join(' ')};\n  grid-template-columns: ${props => props.columns.join(' ')};\n  -ms-grid-rows: ${props => computeIeRows(props.rows, props.spacing)};\n  grid-template-rows: ${props => props.rows.join(' ')};\n  grid-gap: ${props => props.spacing.join(' ')};\n`;\nconst GridLayout = styled(BasicGridLayout)`\n  opacity: 0.9999;\n`;\nconst ShadowGrid = styled(BasicGridLayout)`\n  position: absolute;\n`;\nconst DefaultUnusedCell = styled.div`\n  width: 100%;\n  height: 100%;\n  background: #f1f1f1;\n`; // Remark:\n// At PR #258 a fix for \"complex content that overflows\" was introduced\n// which caused some problem. If this fix should be required in the future\n// again we should bring in something like the following:\n//\n// ```css\n// overflow: auto;\n// margin: -1em;\n// padding: 1em;\n// ```\n\nconst GridCell = styled.div`\n  -ms-grid-row: ${props => props.ri + 1};\n  -ms-grid-row-span: ${props => props.rf - props.ri};\n  grid-row: ${props => props.ri + 1} / span ${props => props.rf - props.ri};\n  -ms-grid-column: ${props => props.ci + 1};\n  -ms-grid-column-span: ${props => props.cf - props.ci};\n  grid-column: ${props => props.ci + 1} / span ${props => props.cf - props.ci};\n  max-width: 100%;\n`;\nconst HiddenGridCell = styled.div`\n  width: 0;\n  height: 0;\n  overflow: hidden;\n`;\n\nfunction repeat(n, dim = '1fr') {\n  if (typeof n === 'number') {\n    const arr = [];\n\n    for (let i = 0; i < n; i++) {\n      arr.push(dim);\n    }\n\n    return arr;\n  } else if (!n) {\n    return [dim];\n  }\n\n  return n;\n}\n\nfunction period(unit) {\n  if (typeof unit === 'string') {\n    return [unit, unit];\n  } else if (!unit) {\n    return ['0', '0'];\n  }\n\n  return unit;\n}\n\nfunction getEmptyComponent(showEmptyCells) {\n  if (showEmptyCells === true) {\n    return (row, col) => React.createElement(DefaultUnusedCell, {\n      key: `uc-${row}-${col}`\n    });\n  } else if (typeof showEmptyCells === 'object') {\n    return (row, col) => React.cloneElement(showEmptyCells, {\n      key: `uc-${row}-${col}`\n    });\n  } else {\n    return showEmptyCells;\n  }\n}\n\nfunction computeAllocations(props) {\n  const {\n    children,\n    rows,\n    columns\n  } = props;\n  const allocation = [];\n  const layout = calcLayout(children, {\n    rows: typeof rows !== 'string' ? rows : undefined,\n    columns: typeof columns !== 'string' ? columns : undefined\n  });\n  const cells = React.Children.map(children, (child, index) => {\n    const position = layout.cells[index];\n\n    if (child && position) {\n      allocation.push(position);\n      const {\n        colSpan,\n        column,\n        row,\n        rowSpan\n      } = position;\n\n      if (!colSpan || !rowSpan) {\n        return React.createElement(HiddenGridCell, null, child);\n      }\n\n      return React.createElement(GridCell, {\n        ci: column,\n        cf: column + colSpan,\n        ri: row,\n        rf: row + rowSpan,\n        key: index\n      }, child);\n    }\n\n    return undefined;\n  }) || [];\n  return {\n    allocation,\n    cells,\n    rows: typeof rows === 'string' ? repeat(layout.rows, rows) : repeat(rows || layout.rows),\n    columns: typeof columns === 'string' ? repeat(layout.columns, columns) : repeat(columns || layout.columns)\n  };\n}\n\nfunction computeUnused(props, layout) {\n  const {\n    showEmptyCells\n  } = props;\n  const {\n    rows,\n    columns\n  } = layout;\n  const unusedCells = [];\n\n  if (showEmptyCells) {\n    const renderer = getEmptyComponent(showEmptyCells);\n    const rowCount = rows.length;\n    const colCount = columns.length;\n\n    for (let i = 0; i < rowCount; i++) {\n      for (let j = 0; j < colCount; j++) {\n        const cell = renderer(i, j);\n        unusedCells.push(cell);\n      }\n    }\n  }\n\n  return unusedCells;\n}\n/**\n * The `Grid` component represents a uniform grid, i.e., a grid that does not change its column layout from row to row.\n */\n\n\nexport class Grid extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    const layout = computeAllocations(props);\n    this.state = {\n      layout,\n      unused: computeUnused(props, layout)\n    };\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    const currLayout = this.state.layout;\n    const nextLayout = computeAllocations(nextProps);\n    this.setState({\n      layout: nextLayout\n    });\n\n    if (nextProps.showEmptyCells !== this.props.showEmptyCells || nextLayout.rows !== currLayout.rows || nextLayout.columns !== currLayout.columns) {\n      this.setState({\n        unused: computeUnused(nextProps, nextLayout)\n      });\n    }\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      rows: _0,\n      columns: _1,\n      spacing = 0,\n      showEmptyCells: _2,\n      onLayout,\n      innerRef\n    } = _a,\n          props = __rest(_a, [\"rows\", \"columns\", \"spacing\", \"showEmptyCells\", \"onLayout\", \"innerRef\"]);\n\n    const {\n      layout,\n      unused\n    } = this.state;\n    const space = typeof spacing === 'number' ? `${spacing}px` : spacing;\n    const selectedSpacing = period(space);\n\n    if (typeof onLayout === 'function') {\n      onLayout({\n        layout\n      });\n    }\n\n    return React.createElement(StyledGridWrapper, {\n      ref: innerRef\n    }, !!unused.length && React.createElement(ShadowGrid, {\n      rows: layout.rows,\n      columns: layout.columns,\n      spacing: selectedSpacing\n    }, unused), React.createElement(GridLayout, Object.assign({\n      rows: layout.rows,\n      columns: layout.columns,\n      spacing: selectedSpacing\n    }, props), layout.cells));\n  }\n\n}\nGrid.inner = {\n  get StyledGridWrapper() {\n    return StyledGridWrapper;\n  },\n\n  get ShadowGrid() {\n    return ShadowGrid;\n  },\n\n  get GridLayout() {\n    return GridLayout;\n  }\n\n};","map":{"version":3,"sources":["../../../../src/components/Grid/index.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport styled from '../../utils/styled';\nimport { StandardProps } from '../../common';\nimport { GridAreaProps } from '../GridArea';\nimport { calcLayout, GridAllocation } from '../../utils/gridLayout';\nimport { isIE } from '../../utils/browser';\nexport interface EmptyCellRenderer {\n    (row: number, col: number): JSX.Element;\n}\nexport interface GridProps extends StandardProps {\n    /**\n     * Sets the number of rows in the grid, otherwise either 1\n     * (columns not fixed) or dynamic (columns fixed).\n     * A string indicates the height of rows in a dynamic setting.\n     * @default 1\n     */\n    rows?: number | string | Array<string>;\n    /**\n     * Sets the number of columns in the grid, otherwise either\n     * 1 (rows not fixed) or dynamic (rows fixed).\n     * A string indicates the width of columns in a dynamic setting.\n     * @default 1\n     */\n    columns?: number | string | Array<string>;\n    /**\n     * Optionally sets the spacing between the grid cells.\n     * By default 0, otherwise a single value sets the\n     * spacing between rows and columns, while two values\n     * set the spacing between the rows and columns\n     * respectively.\n     * @default 0\n     */\n    spacing?: number | string | [string, string];\n    /**\n     * Sets the grid's children.\n     */\n    children?: React.ReactNode;\n    /**\n     * By providing the show empty cell property, the grid will automatically\n     * render the empty (i.e., unused) cells and populate them using this\n     * component.\n     * @default false\n     */\n    showEmptyCells?: JSX.Element | EmptyCellRenderer | boolean;\n    /**\n     * Event fired once the layout has been computed.\n     */\n    onLayout?(e: GridLayoutEvent): void;\n    /**\n     * Gets the reference to the underlying HTML DOM element.\n     */\n    innerRef?(instance: HTMLElement | null): void;\n}\nexport interface GridLayoutEvent {\n    layout: GridLayout;\n}\nexport interface GridLayout {\n    allocation: Array<GridAllocation>;\n    cells: Array<JSX.Element | undefined>;\n    rows: Array<string>;\n    columns: Array<string>;\n}\nexport interface GridState {\n    layout: GridLayout;\n    unused: Array<JSX.Element>;\n}\ninterface GridLayoutProps {\n    rows: Array<string>;\n    columns: Array<string>;\n    spacing: [string, string];\n}\nconst StyledGridWrapper = styled.div `\n  position: relative;\n`;\nfunction addPx(original: string, space: number) {\n    if (original.endsWith('px')) {\n        const dim = +original.replace('px', '');\n        return `${dim + space}px`;\n    }\n    return original;\n}\nfunction computeIeRows(rows: Array<string>, spacing: [string, string]) {\n    if (isIE === 'IE11') {\n        const [, rowSpace] = spacing;\n        if (rowSpace && rowSpace.endsWith('px')) {\n            const space = +rowSpace.replace('px', '');\n            if (space) {\n                const end = rows.length - 1;\n                return rows.map((row, i) => (i !== end ? addPx(row, space) : row)).join(' ');\n            }\n        }\n    }\n    return rows.join(' ');\n}\nconst BasicGridLayout = styled.div<GridLayoutProps> `\n  height: 100%;\n  width: 100%;\n  display: -ms-grid;\n  display: grid;\n  -ms-grid-columns: ${props => props.columns.join(' ')};\n  grid-template-columns: ${props => props.columns.join(' ')};\n  -ms-grid-rows: ${props => computeIeRows(props.rows, props.spacing)};\n  grid-template-rows: ${props => props.rows.join(' ')};\n  grid-gap: ${props => props.spacing.join(' ')};\n`;\nconst GridLayout = styled(BasicGridLayout) `\n  opacity: 0.9999;\n`;\nconst ShadowGrid = styled(BasicGridLayout) `\n  position: absolute;\n`;\nconst DefaultUnusedCell = styled.div `\n  width: 100%;\n  height: 100%;\n  background: #f1f1f1;\n`;\ninterface GridCellProps {\n    ri: number;\n    rf: number;\n    ci: number;\n    cf: number;\n}\n// Remark:\n// At PR #258 a fix for \"complex content that overflows\" was introduced\n// which caused some problem. If this fix should be required in the future\n// again we should bring in something like the following:\n//\n// ```css\n// overflow: auto;\n// margin: -1em;\n// padding: 1em;\n// ```\nconst GridCell = styled.div<GridCellProps> `\n  -ms-grid-row: ${props => props.ri + 1};\n  -ms-grid-row-span: ${props => props.rf - props.ri};\n  grid-row: ${props => props.ri + 1} / span ${props => props.rf - props.ri};\n  -ms-grid-column: ${props => props.ci + 1};\n  -ms-grid-column-span: ${props => props.cf - props.ci};\n  grid-column: ${props => props.ci + 1} / span ${props => props.cf - props.ci};\n  max-width: 100%;\n`;\nconst HiddenGridCell = styled.div `\n  width: 0;\n  height: 0;\n  overflow: hidden;\n`;\nfunction repeat(n: number | Array<string> | undefined, dim = '1fr') {\n    if (typeof n === 'number') {\n        const arr: Array<string> = [];\n        for (let i = 0; i < n; i++) {\n            arr.push(dim);\n        }\n        return arr;\n    }\n    else if (!n) {\n        return [dim];\n    }\n    return n;\n}\nfunction period(unit: string | [string, string] | undefined): [string, string] {\n    if (typeof unit === 'string') {\n        return [unit, unit];\n    }\n    else if (!unit) {\n        return ['0', '0'];\n    }\n    return unit;\n}\nfunction getEmptyComponent(showEmptyCells: JSX.Element | EmptyCellRenderer | true): EmptyCellRenderer {\n    if (showEmptyCells === true) {\n        return (row, col) => <DefaultUnusedCell key={`uc-${row}-${col}`}/>;\n    }\n    else if (typeof showEmptyCells === 'object') {\n        return (row, col) => React.cloneElement(showEmptyCells, { key: `uc-${row}-${col}` });\n    }\n    else {\n        return showEmptyCells;\n    }\n}\ntype GridChild = React.ReactElement<GridAreaProps> & {\n    type: string;\n};\nfunction computeAllocations(props: GridProps): GridLayout {\n    const { children, rows, columns } = props;\n    const allocation: Array<GridAllocation> = [];\n    const layout = calcLayout(children, {\n        rows: typeof rows !== 'string' ? rows : undefined,\n        columns: typeof columns !== 'string' ? columns : undefined,\n    });\n    const cells = React.Children.map(children, (child: GridChild, index) => {\n        const position = layout.cells[index];\n        if (child && position) {\n            allocation.push(position);\n            const { colSpan, column, row, rowSpan } = position;\n            if (!colSpan || !rowSpan) {\n                return <HiddenGridCell>{child}</HiddenGridCell>;\n            }\n            return (<GridCell ci={column} cf={column + colSpan} ri={row} rf={row + rowSpan} key={index}>\n            {child}\n          </GridCell>);\n        }\n        return undefined;\n    }) || [];\n    return {\n        allocation,\n        cells,\n        rows: typeof rows === 'string' ? repeat(layout.rows, rows) : repeat(rows || layout.rows),\n        columns: typeof columns === 'string' ? repeat(layout.columns, columns) : repeat(columns || layout.columns),\n    };\n}\nfunction computeUnused(props: GridProps, layout: GridLayout) {\n    const { showEmptyCells } = props;\n    const { rows, columns } = layout;\n    const unusedCells: Array<JSX.Element> = [];\n    if (showEmptyCells) {\n        const renderer = getEmptyComponent(showEmptyCells);\n        const rowCount = rows.length;\n        const colCount = columns.length;\n        for (let i = 0; i < rowCount; i++) {\n            for (let j = 0; j < colCount; j++) {\n                const cell = renderer(i, j);\n                unusedCells.push(cell);\n            }\n        }\n    }\n    return unusedCells;\n}\n/**\n * The `Grid` component represents a uniform grid, i.e., a grid that does not change its column layout from row to row.\n */\nexport class Grid extends React.PureComponent<GridProps, GridState> {\n    constructor(props: GridProps) {\n        super(props);\n        const layout = computeAllocations(props);\n        this.state = {\n            layout,\n            unused: computeUnused(props, layout),\n        };\n    }\n    UNSAFE_componentWillReceiveProps(nextProps: GridProps) {\n        const currLayout = this.state.layout;\n        const nextLayout = computeAllocations(nextProps);\n        this.setState({\n            layout: nextLayout,\n        });\n        if (nextProps.showEmptyCells !== this.props.showEmptyCells ||\n            nextLayout.rows !== currLayout.rows ||\n            nextLayout.columns !== currLayout.columns) {\n            this.setState({\n                unused: computeUnused(nextProps, nextLayout),\n            });\n        }\n    }\n    render() {\n        const { rows: _0, columns: _1, spacing = 0, showEmptyCells: _2, onLayout, innerRef, ...props } = this.props;\n        const { layout, unused } = this.state;\n        const space = typeof spacing === 'number' ? `${spacing}px` : spacing;\n        const selectedSpacing = period(space);\n        if (typeof onLayout === 'function') {\n            onLayout({\n                layout,\n            });\n        }\n        return (<StyledGridWrapper ref={innerRef}>\n        {!!unused.length && (<ShadowGrid rows={layout.rows} columns={layout.columns} spacing={selectedSpacing}>\n            {unused}\n          </ShadowGrid>)}\n        <GridLayout rows={layout.rows} columns={layout.columns} spacing={selectedSpacing} {...props}>\n          {layout.cells}\n        </GridLayout>\n      </StyledGridWrapper>);\n    }\n    static inner = {\n        get StyledGridWrapper() { return StyledGridWrapper as typeof StyledGridWrapper; },\n        get ShadowGrid() { return ShadowGrid as typeof ShadowGrid; },\n        get GridLayout() { return GridLayout as typeof GridLayout; }\n    };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
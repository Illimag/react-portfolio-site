{"ast":null,"code":"import * as React from 'react';\nimport { getWidthBreakpointsQuery, getScreenSizeBreakpoints, getMediaQueries } from '../../utils/displayTo';\nimport { light, breakpoints } from '../../themes';\nexport class Responsive extends React.Component {\n  constructor(props) {\n    super(props);\n    this.mediaQueriesToListen = {};\n\n    this.updateMatches = () => {\n      this.setState({\n        matchesTo: this.currentlyMatches()\n      });\n    };\n\n    const {\n      theme = light,\n      screenSize,\n      screenSizeCondition = 'equal',\n      render\n    } = this.props;\n    const themedBreakpoints = Object.assign({}, breakpoints, theme.breakpoints);\n\n    if (screenSize) {\n      const screenSizeBreakpoints = this.getBreakpoints(themedBreakpoints, screenSize, screenSizeCondition);\n\n      if (screenSizeBreakpoints) {\n        this.mediaQueriesToListen[screenSize] = window.matchMedia(getWidthBreakpointsQuery(screenSizeBreakpoints));\n      }\n    } else {\n      const allMediaQueries = getMediaQueries(themedBreakpoints);\n\n      for (const screenSize in allMediaQueries) {\n        this.mediaQueriesToListen[screenSize] = window.matchMedia(allMediaQueries[screenSize]);\n      }\n    }\n\n    if (typeof render !== 'function' && !Object.keys(this.mediaQueriesToListen).length) {\n      console.error('`render` callback method or valid `screenSize` and `screenSizeCondition` should be defined');\n    }\n\n    this.state = {\n      matchesTo: undefined\n    };\n  }\n\n  getBreakpoints(breakpoints, screenSize, screenSizeCondition) {\n    const screenSizeBreakpoints = getScreenSizeBreakpoints(screenSize, breakpoints);\n\n    if (!screenSizeBreakpoints) {\n      console.error(`Invalid screen size ${screenSize}`);\n      return;\n    }\n\n    switch (screenSizeCondition) {\n      case 'equal':\n        return Object.assign({}, screenSizeBreakpoints);\n\n      case 'from':\n        return Object.assign({}, screenSizeBreakpoints, {\n          max: undefined\n        });\n\n      case 'upTo':\n        return Object.assign({}, screenSizeBreakpoints, {\n          min: undefined\n        });\n\n      default:\n        console.error(`Invalid screen size condition ${screenSizeCondition}`);\n        return;\n    }\n  }\n\n  currentlyMatches() {\n    const mediaQueries = this.mediaQueriesToListen;\n\n    for (const screenSize of Object.keys(mediaQueries)) {\n      if (mediaQueries[screenSize].matches) {\n        return screenSize;\n      }\n    }\n\n    return undefined;\n  }\n\n  componentDidMount() {\n    for (const screenSizeListenTo in this.mediaQueriesToListen) {\n      this.mediaQueriesToListen[screenSizeListenTo].addListener(this.updateMatches);\n    }\n\n    this.updateMatches();\n  }\n\n  componentWillUnmount() {\n    for (const sceenSize of Object.keys(this.mediaQueriesToListen)) {\n      this.mediaQueriesToListen[sceenSize].removeListener(this.updateMatches);\n    }\n  }\n\n  render() {\n    const {\n      children,\n      render\n    } = this.props;\n    const {\n      matchesTo\n    } = this.state;\n\n    if (render) {\n      return render(matchesTo);\n    } else {\n      return children && matchesTo ? React.createElement(React.Fragment, null, children) : false;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/components/Responsive/index.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getWidthBreakpointsQuery, getScreenSizeBreakpoints, getMediaQueries } from '../../utils/displayTo';\nimport { PreciseTheme, ScreenSize, Breakpoints } from '../../common';\nimport { light, breakpoints } from '../../themes';\nexport type ScreenSizeCondition = 'equal' | 'from' | 'upTo';\nexport interface ResponsiveProps {\n    /**\n     * Sets the screen size for which to show the children.\n     * Valid values are: 'small' | 'medium' | 'large' | 'xLarge' | 'max'\n     */\n    screenSize?: ScreenSize;\n    /**\n     * Sets the screen size check condition.\n     * Valid values are: 'equal' | 'from' | 'upTo'\n     * @default 'equal'\n     */\n    screenSizeCondition?: ScreenSizeCondition;\n    /**\n     * Sets the render callback. When screen size changes it's called with a new one.\n     */\n    render?(screenSize?: ScreenSize): React.ReactNode;\n    /**\n     * The content to be displayed when the query matches.\n     */\n    children?: React.ReactNode;\n    /**\n     * The theme to supply for setting the custom breakpoints, if any.\n     */\n    theme?: PreciseTheme;\n}\nexport interface ResponsiveState {\n    matchesTo?: ScreenSize;\n}\nexport class Responsive extends React.Component<ResponsiveProps, ResponsiveState> {\n    private mediaQueriesToListen: {\n        [size: string]: MediaQueryList;\n    } = {};\n    constructor(props: ResponsiveProps) {\n        super(props);\n        const { theme = light, screenSize, screenSizeCondition = 'equal', render } = this.props;\n        const themedBreakpoints = { ...breakpoints, ...theme.breakpoints };\n        if (screenSize) {\n            const screenSizeBreakpoints = this.getBreakpoints(themedBreakpoints, screenSize, screenSizeCondition);\n            if (screenSizeBreakpoints) {\n                this.mediaQueriesToListen[screenSize] = window.matchMedia(getWidthBreakpointsQuery(screenSizeBreakpoints));\n            }\n        }\n        else {\n            const allMediaQueries = getMediaQueries(themedBreakpoints);\n            for (const screenSize in allMediaQueries) {\n                this.mediaQueriesToListen[screenSize] = window.matchMedia(allMediaQueries[screenSize]);\n            }\n        }\n        if (typeof render !== 'function' && !Object.keys(this.mediaQueriesToListen).length) {\n            console.error('`render` callback method or valid `screenSize` and `screenSizeCondition` should be defined');\n        }\n        this.state = {\n            matchesTo: undefined,\n        };\n    }\n    private getBreakpoints(breakpoints: Breakpoints, screenSize: ScreenSize, screenSizeCondition: ScreenSizeCondition) {\n        const screenSizeBreakpoints = getScreenSizeBreakpoints(screenSize, breakpoints);\n        if (!screenSizeBreakpoints) {\n            console.error(`Invalid screen size ${screenSize}`);\n            return;\n        }\n        switch (screenSizeCondition) {\n            case 'equal':\n                return { ...screenSizeBreakpoints };\n            case 'from':\n                return { ...screenSizeBreakpoints, max: undefined };\n            case 'upTo':\n                return { ...screenSizeBreakpoints, min: undefined };\n            default:\n                console.error(`Invalid screen size condition ${screenSizeCondition}`);\n                return;\n        }\n    }\n    private currentlyMatches() {\n        const mediaQueries = this.mediaQueriesToListen;\n        for (const screenSize of Object.keys(mediaQueries)) {\n            if (mediaQueries[screenSize].matches) {\n                return screenSize as ScreenSize;\n            }\n        }\n        return undefined;\n    }\n    private updateMatches = () => {\n        this.setState({\n            matchesTo: this.currentlyMatches(),\n        });\n    };\n    componentDidMount() {\n        for (const screenSizeListenTo in this.mediaQueriesToListen) {\n            this.mediaQueriesToListen[screenSizeListenTo].addListener(this.updateMatches);\n        }\n        this.updateMatches();\n    }\n    componentWillUnmount() {\n        for (const sceenSize of Object.keys(this.mediaQueriesToListen)) {\n            this.mediaQueriesToListen[sceenSize].removeListener(this.updateMatches);\n        }\n    }\n    render() {\n        const { children, render } = this.props;\n        const { matchesTo } = this.state;\n        if (render) {\n            return render(matchesTo);\n        }\n        else {\n            return children && matchesTo ? <>{children}</> : false;\n        }\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}